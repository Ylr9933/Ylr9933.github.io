<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>个人网页展示</title>
    <link href="/2024/08/07/%E4%B8%AA%E4%BA%BA%E7%BD%91%E9%A1%B5%E5%B1%95%E7%A4%BA/"/>
    <url>/2024/08/07/%E4%B8%AA%E4%BA%BA%E7%BD%91%E9%A1%B5%E5%B1%95%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="初学前端做的几个小网页"><a href="#初学前端做的几个小网页" class="headerlink" title="初学前端做的几个小网页"></a>初学前端做的几个小网页</h2><p><a href="https://github.com/Ylr9933/Ylr9933.github.io/web/cat/index.html" target="_blank">猫猫！</a></p><p><a href="https://github.com/Ylr9933/Ylr9933.github.io/web/coffee/index.html" target="_blank">咖啡</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>website</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git教程2</title>
    <link href="/2024/07/27/git%E6%95%99%E7%A8%8B2/"/>
    <url>/2024/07/27/git%E6%95%99%E7%A8%8B2/</url>
    
    <content type="html"><![CDATA[<h2 id="git的工作区域和文件状态"><a href="#git的工作区域和文件状态" class="headerlink" title="git的工作区域和文件状态"></a>git的工作区域和文件状态</h2><p>git的工作区域分为三个区：<br>工作区（Working Directory）:自己电脑上的本地目录，能够在资源管理器中看到的文件夹。<br>暂存区（Staging Area&#x2F;Index）：临时存储区域，用于保存即将提交到git仓库的修改内容。<br>本地仓库（Loacl Repository）：通过git init创建的仓库，包含了完整的项目历史和元数据，是git存储代码和版本信息的主要位置<br><img src="/../img/git%E6%95%99%E7%A8%8B2-image.png" alt="alt text"><br>文件有四种状态：未跟踪（Untrack），未修改（Unmodified），已修改（Modified），已暂存（staged）<br><img src="/../img/git%E6%95%99%E7%A8%8B2-image-2.png" alt="alt text"></p><h2 id="添加和提交文件"><a href="#添加和提交文件" class="headerlink" title="添加和提交文件"></a>添加和提交文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs git">git init # 创建仓库<br>git status # 查看仓库的状态<br>git add # 添加到暂存区<br>git commit # 提交<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">echo &quot;这是一个文件&quot;&gt;file1.txt # 创建一个文件并写入内容<br>cat file1.txt # 打印文件内容<br>git status # 查看仓库状态<br></code></pre></td></tr></table></figure><p>红色表示未被跟踪的文件<br><img src="/../img/git%E6%95%99%E7%A8%8B2-image-1.png" alt="alt text"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git add file1.txt # 将文件添加到暂存区<br>git restore --staged file1.txt # 用于取消暂存<br></code></pre></td></tr></table></figure><p>绿色表示这个文件已经被添加到暂存区，等待被提交<br><img src="/../img/git%E6%95%99%E7%A8%8B2-image-3.png" alt="alt text"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">git commit -m &quot;第一次提交&quot;<br><br># 将文件提交到仓库中(只会提交暂存区中的文件)，-m后跟提交信息<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git add *.txt # 将所有txt后缀的文件提交，*是通配符<br>git add . # 将所有文件提交到暂存区，.表示当前目录<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git log # 查看提交记录（按q退出）<br></code></pre></td></tr></table></figure><h2 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a>回退版本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">git reset --soft &lt;ID&gt; # 回退到某一个版本并且保留工作区和暂存区的所有修改内容<br>git reset --hard &lt;ID&gt; # 丢弃工作区和暂存区的修改内容<br>git reset --mixed &lt;ID&gt; # 只保留工作区的修改内容（默认参数）<br></code></pre></td></tr></table></figure><p>后面是要回退的版本ID，用git log可以查看版本ID</p><h2 id="查看差异"><a href="#查看差异" class="headerlink" title="查看差异"></a>查看差异</h2><p>指令：git diff<br><img src="/../img/git%E6%95%99%E7%A8%8B2-image-4.png" alt="alt text"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs git">git diff # 不加参数默认查看工作区和暂存区之间的差异<br>git diff HEAD # 查看工作区和版本库之间的差异<br>git diff --cached # 比较暂存区和版本库之间的差异<br>git diff &lt;ID&gt; &lt;ID&gt; # 比较两个版本之间的差异 <br>#  HEAD表示当前版本，HEAD~表示上一个版本<br></code></pre></td></tr></table></figure><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">rm &quot;filename&quot; #删除工作区文件<br>git commit &quot;filename&quot; # 将改动提交到暂存区<br>git commit # 将改动提交到版本库<br></code></pre></td></tr></table></figure><h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><p>.gitignore文件中保存的是不提交到版本库中的文件名，前提是这个文件在版本库中不存在<br><img src="/../img/git%E6%95%99%E7%A8%8B2-image-5.png" alt="alt text"></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git教程1</title>
    <link href="/2024/07/27/git%E6%95%99%E7%A8%8B1/"/>
    <url>/2024/07/27/git%E6%95%99%E7%A8%8B1/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是git"><a href="#什么是git" class="headerlink" title="什么是git"></a>什么是git</h2><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。超过90%的开源项目都在使用git进行版本控制，github，gitlab，gitee等网站上托管的开源项目也都是使用git来进行管理的，对开发者来说，掌握git可以说是必不可少的技能。</p><h2 id="git的使用方式"><a href="#git的使用方式" class="headerlink" title="git的使用方式"></a>git的使用方式</h2><ul><li>命令行</li><li>图形界面(GUI)</li><li>IDE插件&#x2F;扩展</li></ul><h2 id="安装和初始化配置"><a href="#安装和初始化配置" class="headerlink" title="安装和初始化配置"></a>安装和初始化配置</h2><p>访问<a href="https://git-scm.com/">git官网</a>选择下载<br><img src="/../img/git%E6%95%99%E7%A8%8B-image.png" alt="alt text"><br>选择download，安装完成后在终端输入指令查看版本信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git -v<br></code></pre></td></tr></table></figure><p>如果能够看到版本信息，说明下载成功。安装git后会自动安装gitbash<br><img src="/../img/git%E6%95%99%E7%A8%8B-image-1.png" alt="alt text"></p><p>第一步，打开git bash，用git config命令配置用户名和邮箱</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs git">git config --global user.name &quot;YLR&quot; # 如果用户名没有空格可以省略引号<br>gitconfig --global user.email 2840392900@qq.com<br>git config --global credential.helper store # 保存用户名和密码<br>git config --global --list # 查看git的配置信息<br></code></pre></td></tr></table></figure><p>–global:全局配置，对所有仓库生效<br>–system:系统配置，对所有用户生效<br>缺省(Local):本地配置，只对本地仓库有效</p><h2 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h2><p>版本库又叫仓库，英文名repository，简称repo，可以理解为一个目录，这个目录里面的所有文件都能被git管理起来，每个文件的修改，删除，添加等操作git都能跟踪到，以便任何时候都可以追踪历史或者还原到之前的某一个版本</p><p>方式一：git init，在自己电脑本地创建一个仓库\</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">mkdir learn-git #创建文件夹<br>cd learn-git # 进入文件夹<br>git init # 初始化仓库<br></code></pre></td></tr></table></figure><p><img src="/../img/git%E6%95%99%E7%A8%8B-image-2.png" alt="alt text"></p><p>方式二：git clone，从远程服务器上克隆一个已经存在的仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git clone &quot;https://github.com/Ylr9933/Notebook&quot; # 远程仓库地址<br></code></pre></td></tr></table></figure><p><img src="/../img/git%E6%95%99%E7%A8%8B-image-3.png" alt="alt text"></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>买卖股票的最佳时机（dp问题）</title>
    <link href="/2024/07/26/dp/"/>
    <url>/2024/07/26/dp/</url>
    
    <content type="html"><![CDATA[<h3 id="0-问题概述"><a href="#0-问题概述" class="headerlink" title="0.问题概述"></a>0.问题概述</h3><p>给定一段时间内股票的价格，求解如何买卖股票可以获得最大收益</p><p>这是一类典型的动态规划问题</p><h3 id="1-只能进行一次交易"><a href="#1-只能进行一次交易" class="headerlink" title="1.只能进行一次交易"></a>1.只能进行一次交易</h3><!-- 1 --><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">原题链接</a></p><p><a href="#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">返回目录</a></p><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h4><p>给定一个数组 <strong>prices</strong> ，它的第 <strong>i</strong> 个元素 <strong>prices[i]</strong> 表示一支给定股票第 <strong>i</strong> 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。</p><p>设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <strong>0</strong> 。</p><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a><strong>分析：</strong></h4><p>交易股票过程中，当我们想卖出股票时，我们总会想在这之前以最低价格买入股票，</p><p>假设第<strong>i</strong>天我们卖出股票，在什么情况下收益最大呢，</p><p>只要我们在前<strong>i-1</strong>天的最低点买入这支股票，这样在第i天卖出时就能保证获得最大利润，</p><p>因此我们可以定义一个变量<strong>minprice</strong>来记录前i-1天股票的最低价格，</p><p><strong>maxprofit</strong>来记录在第i天卖出股票的最大收益，</p><p>接下来遍历price数组，更新最低价格和最大利润：<br><strong>maxprofit&#x3D;max(maxprofit,price[i]-minprofit)</strong><br><strong>minprice&#x3D;min(minprice,price[i])</strong></p><p>这样就能求得最大利润</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> minprice = INT_MAX, maxprofit = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) &#123;<br>            maxprofit = <span class="hljs-built_in">max</span>(maxprofit, price[i] - minprice);<br>            minprice = <span class="hljs-built_in">min</span>(price[i], minprice);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxprofit;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><!-- 1 --><h3 id="2-可以进行无限次交易（含冷冻期）"><a href="#2-可以进行无限次交易（含冷冻期）" class="headerlink" title="2.可以进行无限次交易（含冷冻期）"></a>2.可以进行无限次交易（含冷冻期）</h3><!-- 2 --><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/">原题链接</a></p><h4 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h4><p><a href="#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">返回目录</a></p><p>给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。​</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><p>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p><p><strong>注意</strong>：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><h4 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a><strong>分析：</strong></h4><p><strong>重点</strong>:因为可以买卖多次股票，所以不能只用一个变量来记录最大收益，</p><p>应该使用动态规划，即假设前i-1天的最大收益已知，</p><p>则可通过比较求得前i天的最大收益。</p><p>建立状态机并对第i天的情况进行分类讨论，然后进行动态规划</p><p>在交易股票过程中，有三种状态：</p><p><strong>持有股票、没有股票且不处于冷冻期、没有股票且处于冷冻期，</strong></p><p>本题求解的是最大利润，故我们可以用一个二维数组<strong>dp</strong></p><p>来存储每天结束后持有股票和没有股票的最大利润，</p><p>其中dp[i][0]表示第i天结束后持有股票情况下的最大利润，</p><p>dp[i][1]表示第i天结束后没有股票且处于冷冻期的最大利润，</p><p>dp[i][2]表示第i天结束后没有股票且不处于冷冻期的最大利润，</p><p>若第i天持有股票：之前没有股票买了今天的股票或之前就有股票<br>dp[i][0] &#x3D; max(dp[i - 1][0], dp[i - 1][2] - prices[i])</p><p>第i天没有股票且处于冷冻期：昨天有股票，今天把股票卖了<br>dp[i][1] &#x3D; dp[i - 1][0] + prices[i]</p><p>第i天没有股票且不处于冷冻期：前一天可能处于冷冻期也可能不处于<br>dp[i][2] &#x3D; max(dp[i - 1][1], dp[i - 1][2])</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> days = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (days &lt;= <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">dp</span>(days, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-comment">//初始化第0天的情况</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; days; ++i)<br>        &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - prices[i]);<br>            dp[i][<span class="hljs-number">1</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i];<br>            dp[i][<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(dp[days - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[days - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]), dp[days - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><!-- 2 --><h3 id="3-可以进行无限次交易（含手续费）"><a href="#3-可以进行无限次交易（含手续费）" class="headerlink" title="3.可以进行无限次交易（含手续费）"></a>3.可以进行无限次交易（含手续费）</h3><!-- 3 --><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">原题链接</a></p><p><a href="#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">返回目录</a></p><h4 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h4><p>给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析:"></a><strong>分析:</strong></h4><p>本题与上一题没有本质区别，只是多了手续费且没有冷冻期，</p><p>所以只有两个状态：持有股票和没有股票</p><p>第i天没有股票的最大利润和持有股票的最大利润分别用dp[i][0]和dp[i][1]表示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices, <span class="hljs-type">int</span> fee)</span> </span>&#123;<br>        <span class="hljs-type">int</span> days = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (days &lt;= <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">dp</span>(days,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;);<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; days; ++i)<br>        &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i] - fee);<br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[days<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[days<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><!-- 3 --><h3 id="4-可以进行两次交易"><a href="#4-可以进行两次交易" class="headerlink" title="4.可以进行两次交易"></a>4.可以进行两次交易</h3><!-- 4 --><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">原题链接</a></p><p><a href="#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">返回目录</a></p><h4 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h4><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p><strong>注意</strong>：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析:"></a><strong>分析:</strong></h4><p>本题的难点在于可以进行两次交易，所以状态机数量增多，第i天共有5个状态：</p><p>0.从来没有买卖过股票，用dp[i][0]表示（始终为0）</p><p>1.持有一张股票，从没有卖过，用dp[i][1]表示</p><p>2.持有并卖出一张股票，用dp[i][2]表示</p><p>3.持有一张股票，之前持有并卖出过一张股票，用dp[i][3]表示</p><p>4.持有并卖出过两张股票，用dp[i][4]表示</p><p>将五个状态列出来之后，各状态之间的关系是不是瞬间清晰明了了，</p><p>接下来我就不分析了，直接进入代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> days = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (days &lt;= <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">dp</span>(days,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">5</span>,INT_MIN));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; days; ++i)<br>        &#123;<br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>            dp[i][<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[i][<span class="hljs-number">1</span>] + prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);<br>            <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">2</span>)<br>                dp[i][<span class="hljs-number">3</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>]);<br>            <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">3</span>)<br>                dp[i][<span class="hljs-number">4</span>] = <span class="hljs-built_in">max</span>(dp[i][<span class="hljs-number">3</span>] + prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>]);<br>        &#125;<br>        <span class="hljs-type">int</span> max_profits = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i)<br>            <span class="hljs-keyword">if</span> (dp[days<span class="hljs-number">-1</span>][i] &gt; max_profits)<br>                max_profits = dp[days<span class="hljs-number">-1</span>][i];<br>        <span class="hljs-keyword">return</span>  max_profits;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><!-- 4 --><h3 id="5-可以进行k次交易"><a href="#5-可以进行k次交易" class="headerlink" title="5.可以进行k次交易"></a>5.可以进行k次交易</h3><!-- 5 --><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">原题链接</a></p><p><a href="#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">返回目录</a></p><h4 id="题目描述：-4"><a href="#题目描述：-4" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h4><p>给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><h4 id="分析：-2"><a href="#分析：-2" class="headerlink" title="分析："></a><strong>分析：</strong></h4><p>经过上一题的解析，我们注意到，每增加一个买卖次数都会产生两种新状态，</p><p>所以很容易想到k次交易总共有<strong>2*k+1</strong>种状态</p><p>其中dp[i][2*x]表示买卖过x次股票，当前没有股票</p><p>dp[i][2*x+1]表示持有一张股票，之前买卖过x次股票</p><p>接下来问题就变得简单了，只需要对天数遍历的过程，再对状态机遍历，</p><p>就能得到每种状态下的最大利润。</p><p>话不多说，上代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> k, vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> days = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (days &lt;= <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">dp</span>(days, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>, INT_MIN));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>*k + <span class="hljs-number">1</span>; ++i)<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; days; ++i)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i + <span class="hljs-number">1</span>; ++j)&#123;<span class="hljs-comment">//第i天最多买卖i+1次</span><br>                <span class="hljs-keyword">if</span> (j % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<span class="hljs-comment">//持有股票</span><br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][j]);<br>                <span class="hljs-keyword">else</span><span class="hljs-comment">//没有股票</span><br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j - <span class="hljs-number">1</span>] + prices[i], dp[i - <span class="hljs-number">1</span>][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> max_profits = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>; ++i)<br>            <span class="hljs-keyword">if</span> (dp[days - <span class="hljs-number">1</span>][i] &gt; max_profits)<br>                max_profits = dp[days - <span class="hljs-number">1</span>][i];<br>        <span class="hljs-keyword">return</span>  max_profits;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><!-- 5 --><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h3><!-- 6 --><p><a href="#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">返回目录</a></p><p>动态规划是一类经典问题</p><p>它通常用于解决具有重叠子问题和最优子结构性质的问题，</p><p>通过将问题分解为相互依赖的子问题，</p><p>然后通过求解这些子问题的最优解来得到原问题的最优解。</p><p>以下是动态规划问题的一般特征和解决步骤的总结：</p><p><strong>最优子结构</strong>：问题的最优解包含了其子问题的最优解。通过求解子问题的最优解，可以得到原问题的最优解。</p><p><strong>重叠子问题</strong>：问题可以被分解为许多相同的子问题。为了避免重复计算，可以使用记忆化搜索或自底向上的方法来存储已解决的子问题的解，以便以后使用。</p><p><strong>状态转移方程</strong>：动态规划问题通常可以通过状态转移方程来描述，即当前状态的解如何依赖于之前状态的解。</p><p><strong>自底向上或自顶向下</strong>：解决动态规划问题的方法通常分为自底向上和自顶向下两种。自底向上是从最底层的子问题开始逐步求解，直到得到原问题的解；自顶向下是从原问题开始，通过递归地求解子问题来得到解。</p><p><strong>状态压缩</strong>：在一些问题中，可以通过状态压缩来减少空间复杂度。这意味着只存储必要的状态，而不是全部状态。</p><p><strong>边界条件</strong>：在解决动态规划问题时，需要注意边界条件，即最小的子问题可能需要特殊处理。</p><p>在本类股票交易问题中，求第i天最大利润的子问题即为前i-1天的最大利润，</p><p>一旦找到与子问题的关系，列出状态转移方程，这类问题就能够迎刃而解</p><!-- 6 -->]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>31指令CPU</title>
    <link href="/2024/07/26/CPU31/"/>
    <url>/2024/07/26/CPU31/</url>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>本实验中我将使用Verilog HDL语言设计一个31条指令单周期的CPU设计，并完成前仿真、后仿真和下板调试运行。设计CPU是一项繁杂的任务，在此过程中，要明确每一步设计流程，才能减少Debug的时间（改bug怎的很费时间），提高效率。<br>大致流程如下：列出CPU指令表→绘制各个指令的数据流图→绘制数据流总图→列出指令信号表→编写代码实现CPU基础功能→测试→仿真下板</p><h2 id="2-指令表"><a href="#2-指令表" class="headerlink" title="2.指令表"></a>2.指令表</h2><p>31条指令表如下：<br><img src="/../img/CPU31-image.png" alt="alt text"><br>其中的指令可以分为三类，分别是：</p><p>R-type:<br>OP为000000,由func来决定他的功能，主要用于操作寄存器之间的算术和逻辑运算。rs和rt是源寄存器，通常存操作数，rd是目标寄存器，通常存结果。shamt代表移位操作中的位移量，是立即数。</p><p>I-type:<br>I型指令都包含了一个立即数（常数），用于与常数相关的计算，观察表发现，I型指令将rd，shamt，func替换为了immediate，因此I型指令由op直接决定，rs作为源寄存器，rd作为目标寄存器。</p><p>J-type:<br>J型指令只有两条，用来实现无条件跳转。</p><h2 id="3-数据通路图"><a href="#3-数据通路图" class="headerlink" title="3.数据通路图"></a>3.数据通路图</h2><h3 id="R-type"><a href="#R-type" class="headerlink" title="R-type"></a>R-type</h3><p>1.ADD<br>格式：ADD rd,rs,rt<br>目的：与32位数相加。<br>描述：rd←rs+rt<br>将通用寄存器中存的32位数据rs与rt相加产生一个32位数据存入目标寄存器rd。<br>（1）如果发生了溢出，则rd不改变且产生一个溢出的异常<br>（2）如果相加不溢出，则产生的32位数据直接存入目标寄存器rd。<br>操作：rd←rs+rt,PC←NPC(PC+4)<br>所需部件：PC、NPC、IMEM、Regfile、ALU。<br>指令周期：<br>·取指周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→PC<br>·执行周期：<br>rs→A,rt→B<br>(A+B→result)<br>result→rd<br>指令流程图：<br><img src="/../img/CPU31-image-1.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-2.png" alt="alt text"></p><p>2.ADDU<br>格式：ADDU rd,rs,rt<br>目的：与32位数相加。<br>描述：rd←rs+rt<br>将通用寄存器中存的32位数据rs与rt相加产生一个32位数据存入目标寄存器rd。在任何情况下都不会有溢出的异常<br>操作：rd←rs+rt,PC←NPC(PC+4)<br>所需部件：PC、NPC、IMEM、Regfile、ALU。<br>指令周期：<br>·取指周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→PC<br>·执行周期：<br>rs→A,rt→B<br>(A+B→result)<br>result→rd<br>指令流程图：<br><img src="/../img/CPU31-image-3.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-4.png" alt="alt text"></p><p>3.SUB<br>格式：SUB rd,rs,rt<br>目的：与32位数相减。<br>描述：rd←rs-rt<br>将通用寄存器中存的32位数据rs与rt相减产生一个32位数据存入目标寄存器rd。<br>（1）如果发生了溢出，则rd不改变且产生一个溢出的异常<br>（2）如果相减不溢出，则产生的32位数据直接存入目标寄存器rd。<br>操作：rd←rs-rt,PC←NPC(PC+4)<br>所需部件：PC、NPC、IMEM、Regfile、ALU。<br>指令周期：<br>·取指周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→PC<br>·执行周期：<br>rs→A,rt→B<br>(A-B→result)<br>result→rd<br>指令流程图：<br><img src="/../img/CPU31-image-5.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-6.png" alt="alt text"></p><p>4.SUBU<br>格式：SUBU rd,rs,rt<br>目的：与32位数相减。<br>描述：rd←rs-rt<br>将通用寄存器中存的32位数据rs与rt相减产生一个32位数据存入目标寄存器rd。在任何情况下都不会有溢出的异常<br>操作：rd←rs-rt,PC←NPC(PC+4)<br>所需部件：PC、NPC、IMEM、Regfile、ALU。<br>指令周期：<br>·取指周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→PC<br>·执行周期：<br>rs→A,rt→B<br>(A-B→result)<br>result→rd<br>指令流程图：<br><img src="/../img/CPU31-image-7.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-8.png" alt="alt text"></p><p>5.AND<br>格式：AND rd,rs,rt<br>目的：按位逻辑与。<br>描述：rd←rs AND rt<br>将通用寄存器rs和rt中的数据每一位做按位与操作，将结果存入目标寄存器rd中。<br>操作：rd←rs AND rt,PC←NPC(PC+4)<br>所需部件：PC、NPC、IMEM、Regfile、ALU。<br>指令周期：<br>·取指周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→PC<br>·执行周期：<br>rs→A,rt→B<br>(A AND B→result)<br>result→rd<br>指令流程图：<br><img src="/../img/CPU31-image-9.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-10.png" alt="alt text"><br>6.OR<br>格式：OR rd,rs,rt<br>目的：按位逻辑或。<br>描述：rd←rs OR rt<br>将通用寄存器rs和rt中的数据每一位做按位或操作，将结果存入目标寄存器rd中。<br>操作：rd←rs OR rt,PC←NPC(PC+4)<br>所需部件：PC、NPC、IMEM、Regfile、ALU。<br>指令周期：<br>·取指周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→PC<br>·执行周期：<br>rs→A,rt→B<br>(A OR B→result)<br>result→rd<br>指令流程图：<br><img src="/../img/CPU31-image-11.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-12.png" alt="alt text"></p><p>7.XOR<br>格式：XOR rd,rs,rt<br>目的：按位逻辑异或。<br>描述：rd←rs XOR rt<br>将通用寄存器rs和rt中的数据每一位做按位异或操作，将结果存入目标寄存器rd中。<br>操作：rd←rs XOR rt,PC←NPC(PC+4)<br>所需部件：PC、NPC、IMEM、Regfile、ALU。<br>指令周期：<br>·取指周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→PC<br>·执行周期：<br>rs→A,rt→B<br>(A XOR B→result)<br>result→rd<br>指令流程图：<br><img src="/../img/CPU31-image-13.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-14.png" alt="alt text"></p><p>8.NOR<br>格式：NOR rd,rs,rt<br>目的：按位逻辑或非。<br>描述：rd←rs NOR rt<br>将通用寄存器rs和rt中的数据每一位做按位或非操作，将结果存入目标寄存器rd中。<br>操作：rd←rs NOR rt,PC←NPC(PC+4)<br>所需部件：PC、NPC、IMEM、Regfile、ALU。<br>指令周期：<br>·取指周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→PC<br>·执行周期：<br>rs→A,rt→B<br>(A NOR B→result)<br>result→rd<br>指令流程图：<br><img src="/../img/CPU31-image-15.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-16.png" alt="alt text"></p><p>9.SLT(set less than)<br>格式：SLT rd,rs,rt<br>目的：通过小于的比较来记录结果<br>描述：rd←(rs &lt; rt)<br>比较在rs和rt寄存器中保存的有符号数，用boolean值保存结果到rd寄存器中。如果rs小于rt，则结果为1，反之结果为0。算数比较不会引起溢出异常。<br>操作：rd←(rs &lt; rt),PC←NPC(PC+4)<br>所需部件：PC、NPC、IMEM、Regfile、ALU、EXT1。<br>指令周期：<br>·取指周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→PC<br>·执行周期：<br>rs→A,rt→B<br>(A - B→result)<br>SF→EXT1&#x2F;&#x2F;1位拓展到32位<br>EXT1_OUT→rd<br>指令流程图：<br><img src="/../img/CPU31-image-17.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-18.png" alt="alt text"></p><p>10.SLTU<br>格式：SLTU rd,rs,rt<br>目的：通过小于的比较来记录结果<br>描述：rd←(rs &lt; rt)<br>比较在rs和rt寄存器中保存的无符号数，用boolean值保存结果到rd寄存器中。如果rs小于rt，则结果为1，反之结果为0。算数比较不会引起溢出异常。<br>操作：rd←(rs &lt; rt),PC←NPC(PC+4)<br>所需部件：PC、NPC、IMEM、Regfile、ALU、EXT1。<br>指令周期：<br>·取指周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→PC<br>·执行周期：<br>rs→A,rt→B<br>(A - B→result)<br>SF→EXT1&#x2F;&#x2F;1位拓展到32位<br>EXT1_OUT→rd<br>指令流程图：<br><img src="/../img/CPU31-image-19.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-20.png" alt="alt text"></p><p>11.SLL(shift left logical)<br>格式：SLL rd,rt,sa<br>目的：通过数字0填充逻辑左移<br>描述：rd←rt&lt;&lt;sa<br>将通用寄存器rt的内容左移sa位，空余出来的位置用0来填充，把结果存入rd寄存器<br>操作：rd←rt&lt; &lt;sa,PC←NPC(PC+4)<br>所需部件：PC、NPC、IMEM、Regfile、ALU、EXT5。<br>指令周期：<br>·取指周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→PC<br>·执行周期：<br>IMEM[10:6]→EXT5<br>EXT5_OUT→A<br>rt→B<br>(B &lt;&lt; A→result)<br>result→rd<br>指令流程图：<br><img src="/../img/CPU31-image-21.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-22.png" alt="alt text"></p><p>12.SRL(shift right logical)<br>格式：SRL rd,rt,sa<br>目的：通过数字0填充逻辑右移<br>描述：rd←rt&gt;&gt;sa<br>将通用寄存器rt的内容右移sa位，空余出来的位置用0来填充，把结果存入rd寄存器<br>操作：rd←rt&gt;&gt;sa,PC←NPC(PC+4)<br>所需部件：PC、NPC、IMEM、Regfile、ALU、EXT5。<br>指令周期：<br>·取指周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→PC<br>·执行周期：<br>IMEM[10:6]→EXT5<br>EXT5_OUT→A<br>rt→B<br>(B &gt;&gt; A→result)<br>result→rd<br>指令流程图：<br><img src="/../img/CPU31-image-23.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-24.png" alt="alt text"></p><p>13.SRA(shift right arithmetic)<br>格式：SRA rd,rt,sa<br>目的：通过数字填充算术右移<br>描述：rd←rt&gt;&gt;sa<br>将通用寄存器rt的32位内容右移sa位，高位用rt[31]来填充，结果存入通用寄存器rd。<br>操作：rd←rt&gt;&gt;sa,PC←NPC(PC+4)<br>所需部件：PC、NPC、IMEM、Regfile、ALU、EXT5。<br>指令周期：<br>·取指周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→PC<br>·执行周期：<br>IMEM[10:6]→EXT5<br>EXT5_OUT→A<br>rt→B<br>(B &gt;&gt; A→result)<br>result→rd<br>指令流程图：<br><img src="/../img/CPU31-image-25.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-26.png" alt="alt text"></p><p>14.SLLV(shift left logic variable)<br>格式：SLLV rd,rt,rs<br>目的：通过数字0填充逻辑左移<br>描述：rd←rt&lt;&lt;rs<br>将通用寄存器rt中的内容逻辑左移，左移的位数保存在rs寄存器中，空余出来的位置用0来填充，把结果存入rd寄存器。<br>操作：rd←rt&lt;&lt;rs,PC←NPC(PC+4)<br>所需部件：PC、NPC、IMEM、Regfile、ALU、EXT5。<br>指令周期：<br>·取指周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→PC<br>·执行周期：<br>rs[4:0]→EXT5<br>EXT5_OUT→A<br>rt→B<br>(B &lt;&lt; A→result)<br>result→rd<br>指令流程图：<br><img src="/../img/CPU31-image-27.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-28.png" alt="alt text"></p><p>15.SRLV(shift right logic variable)<br>格式：SRLV rd,rt,rs<br>目的：通过数字0填充逻辑右移<br>描述：rd←rt&gt;&gt;rs<br>将通用寄存器rt中的32位内容右移，高位用rt[31]来填充，结果存入通用寄存器rd。右移的位数由通用寄存器rs中的0~4bit确定<br>操作：rd←rt&gt;&gt;rs,PC←NPC(PC+4)<br>所需部件：PC、NPC、IMEM、Regfile、ALU、EXT5。<br>指令周期：<br>·取指周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→PC<br>·执行周期：<br>rs[4:0]→EXT5<br>EXT5_OUT→A<br>rt→B<br>(B &gt;&gt; A→result)<br>result→rd<br>指令流程图：<br><img src="/../img/CPU31-image-29.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-30.png" alt="alt text"></p><p>16.SRAV(shift right arithmetic variable)<br>格式：SRAV rd,rt,rs<br>目的：通过数字填充算术右移<br>描述：rd←rt&gt;&gt;rs<br>将通用寄存器rt中的32位内容右移，高位用rt[31]来填充，结果存入通用寄存器rd。右移的位数由通用寄存器rs中的0~4bit确定<br>操作：rd←rt&gt;&gt;rs,PC←NPC(PC+4)<br>所需部件：PC、NPC、IMEM、Regfile、ALU、EXT5。<br>指令周期：<br>·取指周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→PC<br>·执行周期：<br>rs[4:0]→EXT5<br>EXT5_OUT→A<br>rt→B<br>(B &gt;&gt; A→result)<br>result→rd<br>指令流程图：<br><img src="/../img/CPU31-image-31.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-32.png" alt="alt text"></p><p>17.JR(jump register)<br>格式：JR rs<br>目的：使用寄存器的跳转指令<br>描述：PC←rs<br>跳转地址存放在通用寄存器rs中，直接跳转到寄存器所存地址。<br>操作：rd←rt&gt;&gt;rs,PC←NPC(PC+4)<br>所需部件：PC、NPC、IMEM、Regfile、ALU、EXT5。<br>指令周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→MUX<br>rs→MUX&#x2F;&#x2F;多路选择器，选择rs的地址或NPC的地址<br>MUX_OUT→PC<br>指令流程图：<br><img src="/../img/CPU31-image-33.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-34.png" alt="alt text"></p><h3 id="I-type"><a href="#I-type" class="headerlink" title="I-type"></a>I-type</h3><p>18.ADDI<br>格式：ADDI rd,rs,immediate<br>目的：使32位数据与一个立即数相加<br>描述：rd←rs+immediate<br>一个16位有符号的立即数与通用寄存器rs中的32位数相加产生一个32位的数存入目标寄存器rd。<br>（1）如果发生了溢出，则rd不改变且产生一个溢出的异常<br>（2）如果相加不溢出，则结果存入目标寄存器rd。<br>操作：rd←rs+immediate,PC←NPC(PC+4)<br>所需部件：PC、NPC、IMEM、Regfile、ALU、EXT16。<br>指令周期：<br>·取指周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→PC<br>·执行周期：<br>IMEM[15:0]→EXT16<br>EXT16_OUT→B<br>rs→A<br>(A+B→result)<br>result→rd<br>指令流程图：<br><img src="/../img/CPU31-image-35.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-36.png" alt="alt text"></p><p>19.ADDIU<br>格式：ADDIU rd,rs,immediate<br>目的：使32位数据与一个立即数相加<br>描述：rd←rs+immediate<br>一个16位有符号的立即数与通用寄存器rs中的32位数相加产生一个32位的数存入目标寄存器rd。<br>在任何情况下都不会有溢出的异常<br>操作：rd←rs+immediate,PC←NPC(PC+4)<br>所需部件：PC、NPC、IMEM、Regfile、ALU、EXT16。<br>指令周期：<br>·取指周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→PC<br>·执行周期：<br>IMEM[15:0]→EXT16<br>EXT16_OUT→B<br>rs→A<br>(A+B→result)<br>result→rd<br>指令流程图：<br><img src="/../img/CPU31-image-37.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-38.png" alt="alt text"></p><p>20.ANDI<br>格式：ANDI,rd,rs,immediate<br>目的：与一个常数做按位逻辑与。<br>描述：rd←rs AND immediate<br>将16位立即数做0扩展后与通用寄存器rs中的32位数据做按位与，将结果存入目标寄存器rd<br>操作：rd←rs ANDI immediate,PC←NPC(PC+4)<br>所需部件：PC、NPC、IMEM、Regfile、ALU。<br>指令周期：<br>·取指周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→PC<br>·执行周期：<br>IMEM[15:0]→EXT16<br>EXT16_OUT→B<br>rs→A<br>(A&amp;B→result)<br>result→rd<br>指令流程图：<br><img src="/../img/CPU31-image-39.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-40.png" alt="alt text"></p><p>21.ORI<br>格式：ORI,rd,rs,immediate<br>目的：与一个常数做按位逻辑或。<br>描述：rd←rs ORI immediate<br>将16位立即数做0扩展后与通用寄存器rs中的32位数据做按位或，将结果存入目标寄存器rd<br>操作：rd←rs ORI immediate,PC←NPC(PC+4)<br>所需部件：PC、NPC、IMEM、Regfile、ALU。<br>指令周期：<br>·取指周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→PC<br>·执行周期：<br>IMEM[15:0]→EXT16<br>EXT16_OUT→B<br>rs→A<br>(A|B→result)<br>result→rd<br>指令流程图：<br><img src="/../img/CPU31-image-41.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-42.png" alt="alt text"></p><p>22.XORI<br>格式：ORI,rd,rs,immediate<br>目的：与一个常数做按位逻辑异或。<br>描述：rd←rs XORI immediate<br>将16位立即数做0扩展后与通用寄存器rs中的32位数据做按位异或，将结果存入目标寄存器rd<br>操作：rd←rs XORI immediate,PC←NPC(PC+4)<br>所需部件：PC、NPC、IMEM、Regfile、ALU、EXT16。<br>指令周期：<br>·取指周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→PC<br>·执行周期：<br>IMEM[15:0]→EXT16<br>EXT16_OUT→B<br>rs→A<br>(A^B→result)<br>result→rd<br>指令流程图：<br><img src="/../img/CPU31-image-43.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-44.png" alt="alt text"></p><p>23.LW(Load Word)<br>格式：LW rd,offset(base)<br>目的：从内存读取一个字的有符号数据。<br>描述：rd←memory[base + offset]<br>从内存中基地址加偏移量所得到的准确地址中的内容加载到通用寄存器rd中。<br>操作：rd←memory[base + offset],PC←NPC(PC+4)<br>所需部件：PC、NPC、IMEM、Regfile、ALU、EXT16。<br>指令周期：<br>·取指周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→PC<br>·执行周期：<br>IMEM[15:0]→EXT16<br>EXT16_OUT→B<br>rs→A<br>(A + B→result)<br>result→DMEM_ADDR<br>DMEM_OUT→rd<br>指令流程图：<br><img src="/../img/CPU31-image-45.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-46.png" alt="alt text"></p><p>24.SW(Store Word)<br>格式：SW rt,offset(base)<br>目的：存一个字到内存。<br>描述：memory[base + offset]←rt<br>将通用寄存器rt中的32位数据存入内存中的有效地址，有效地址由基地址和16位偏移量相加所得。<br>操作：memory[base + offset]←rt,PC←NPC(PC+4)<br>所需部件：PC、NPC、IMEM、Regfile、ALU、EXT16。<br>指令周期：<br>·取指周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→PC<br>·执行周期：<br>IMEM[15:0]→EXT16<br>EXT16_OUT→B<br>rs→A<br>(A + B→result)<br>Rt→DMEM<br>result→DMEM_ADDR<br>指令流程图：<br><img src="/../img/CPU31-image-47.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-48.png" alt="alt text"></p><p>25.BEQ(Branch if Equal)<br>格式：BEQ rs,rt,offset<br>目的：比较通用寄存器的值，然后做PC相关的分支跳转<br>描述：如果rs&#x3D;rt，那么将offset左移两位（乘以4，因为每条指令的长度是4字节），再进行符号扩展到32位与当前pc相加，形成有效转移地址，转到该地址<br>如果rs!&#x3D;rt，则继续执行下条指令。<br>操作：将rs与rt相减，若结果为0则跳转，否则不跳转。<br>所需部件：PC、NPC、IMEM、Regfile、ALU、EXT18、MUX。<br>指令周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→MUX<br>IMEM[15:0]||02→EXT18<br>EXT18_OUT→ADD_A<br>NPC→ADD_B<br>(ADD_A+ADD_B→ADD_OUT)<br>ADD_OUT→MUX<br>rs→A<br>rt→B<br>(A-B→result)<br>Z→MUX<br>MUX→PC<br>指令流程图：<br><img src="/../img/CPU31-image-49.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-50.png" alt="alt text"></p><p>26.BNE(Branch if not Equal)<br>格式：BNE rs,rt,offset<br>目的：比较通用寄存器的值，然后做PC相关的分支跳转<br>描述：如果rs!&#x3D;rt，那么将offset左移两位（乘以4，因为每条指令的长度是4字节），再进行符号扩展到32位与当前pc相加，形成有效转移地址，转到该地址<br>如果rs&#x3D;rt，则继续执行下条指令。<br>操作：将rs与rt相减，若结果不为0则跳转，否则不跳转。<br>所需部件：PC、NPC、IMEM、Regfile、ALU、EXT18、MUX。<br>指令周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→MUX<br>IMEM[15:0]||02→EXT18<br>EXT18_OUT→ADD_A<br>NPC→ADD_B<br>(ADD_A+ADD_B→ADD_OUT)<br>ADD_OUT→MUX<br>rs→A<br>rt→B<br>(A-B→result)<br>Z→MUX<br>MUX→PC<br>指令流程图：<br><img src="/../img/CPU31-image-51.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-52.png" alt="alt text"></p><p>27.SLTI(Set on Less Than Immediate)<br>格式：SLTI rd,rs,rt<br>目的：比通过跟立即数小于的比较来记录结果。<br>描述：rd←(rs &lt; rt)<br>比较在rs和rt寄存器中保存的有符号数，用boolean值保存结果到rd寄存器中。如过rs小于rt，则结果为1，反之结果为0,。算术比较不会引起溢出异常。<br>操作：rd←(rs &lt; rt),PC←NPC(PC+4)<br>所需部件：PC、NPC、IMEM、Regfile、ALU、EXT1。<br>指令周期：<br>·取指周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→PC<br>·执行周期：<br>IMEM[15:0]→EXT16<br>EXT16_OUT→B<br>rs→A<br>(A-B→result)<br>CF→EXT1<br>EXT1_OUT→rd<br>指令流程图：<br><img src="/../img/CPU31-image-53.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-54.png" alt="alt text"></p><p>28.SLTIU<br>格式：SLTIU rd,rs,rt<br>目的：比通过跟立即数无符号小于的比较来记录结果。<br>描述：rd←(rs &lt; rt)<br>比较在rs和rt寄存器中保存的无符号数，用boolean值保存结果到rd寄存器中。如过rs小于rt，则结果为1，反之结果为0,。算术比较不会引起溢出异常。<br>操作：rd←(rs &lt; rt),PC←NPC(PC+4)<br>所需部件：PC、NPC、IMEM、Regfile、ALU、EXT1。<br>指令周期：<br>·取指周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→PC<br>·执行周期：<br>IMEM[15:0]→EXT16<br>EXT16_OUT→B<br>rs→A<br>(A-B→result)<br>CF→EXT1<br>EXT1_OUT→rd<br>指令流程图：<br><img src="/../img/CPU31-image-55.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-56.png" alt="alt text"></p><p>29.LUI(Load unsigned Immediate)<br>格式：LUI rt,immediate<br>目的：把一个立即数载入到寄存器的高位，低位补0.<br>描述：rt←immediate||016<br>将一个16位的立即数载入到通用寄存器rt的高位，低16位补0。<br>操作：rt←immediate||016,PC←NPC(PC+4)<br>所需部件：PC、NPC、IMEM、Regfile、ALU、EXT16。<br>指令周期：<br>·取指周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→PC<br>·执行周期：<br>IMEM[15:0]→EXT16<br>EXT16_OUT→B<br>result→rd<br>指令流程图：<br><img src="/../img/CPU31-image-57.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-58.png" alt="alt text"></p><h3 id="J-type"><a href="#J-type" class="headerlink" title="J-type"></a>J-type</h3><p>30.J(Jump)<br>格式：J target<br>目的：在256MB的范围内跳转。<br>描述：该指令无条件跳转到一个绝对地址，instr_index有26位，在左移后访问空间能达到228B,即256MB。<br>操作：PC←NPC(target)<br>所需部件：PC、NPC、IMEM、MUX、||。<br>指令周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→MUX<br><br>PC[31:28]→||_A<br>IMEM[25:0]||02→||_B<br>IMEM[15:0]→EXT16<br>||_OUT→MUX<br><br>MUX_OUT→PC<br>指令流程图：<br><img src="/../img/CPU31-image-59.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-60.png" alt="alt text"></p><p>31.JAL(Jump)<br>格式：JAL target<br>目的：在256MB的范围内执行一个过程调用。<br>描述：在跳转到知道地址执行子程序调用的同时，在31号寄存器中存放返回地址（当前地址后的第二条指令地址）<br>操作：rd←NPC(PC+8),PC←NPC(target)<br>所需部件：PC、NPC、IMEM、MUX、||、Regfile、ALU。<br>指令周期：<br>PC→IMEM<br>PC+4→NPC<br>NPC→MUX<br><br>8→A<br>PC→B<br>(A+B→result)<br>result→rd<br><br>PC[31:28]→||_A<br>IMEM[25:0]||02→||_B<br>IMEM[15:0]→EXT16<br>||_OUT→MUX<br><br>MUX_OUT→PC<br>指令流程图：<br><img src="/../img/CPU31-image-61.png" alt="alt text"></p><p>数据通路图：<br><img src="/../img/CPU31-image-62.png" alt="alt text"></p><h2 id="4-数据通路总图"><a href="#4-数据通路总图" class="headerlink" title="4.数据通路总图"></a>4.数据通路总图</h2><p>接下来，将上述31条指令的数据通路图合在一起，形成数据通路总图</p><p><img src="/../img/CPU31-image-63.png" alt="alt text"></p><p>注意，在绘制数据通路总图时，要按照指令顺序依次画，最好同类型指令用同样的颜色标识，方便后期查错。</p><h2 id="5-控制部件设计"><a href="#5-控制部件设计" class="headerlink" title="5.控制部件设计"></a>5.控制部件设计</h2><p>将每条指令对应的所有控制信号列出，有了数据通路图，指令表就非常好写了。我们需要做的是在表中列出每一条指令和图中涉及到的所有操作信号，根据你列出的<br>通路图和每条指令涉及到的操作，将每条指令对应的操作信号标注出来。<br><img src="/../img/CPU31-image-64.png" alt="alt text"><br>这部分内容对应的是control.v中的代码。</p><h2 id="6-代码编写"><a href="#6-代码编写" class="headerlink" title="6.代码编写"></a>6.代码编写</h2><h3 id="控制器Controler"><a href="#控制器Controler" class="headerlink" title="控制器Controler"></a>控制器Controler</h3><p>用于控制运行指令时每个元件的状态。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 1ns / 1ps</span><br><span class="hljs-comment">/* 控制器 */</span><br><span class="hljs-keyword">module</span> Controler(              <span class="hljs-comment">//根据当前要执行的指令输出各个元器件的状态</span><br>    <span class="hljs-keyword">input</span> add_flag,            <span class="hljs-comment">//指令是否为ADD</span><br>    <span class="hljs-keyword">input</span> addu_flag,           <span class="hljs-comment">//指令是否为ADDU</span><br>    <span class="hljs-keyword">input</span> sub_flag,            <span class="hljs-comment">//指令是否为SUB</span><br>    <span class="hljs-keyword">input</span> subu_flag,           <span class="hljs-comment">//指令是否为SUBU</span><br>    <span class="hljs-keyword">input</span> and_flag,            <span class="hljs-comment">//指令是否为AND</span><br>    <span class="hljs-keyword">input</span> or_flag,             <span class="hljs-comment">//指令是否为OR</span><br>    <span class="hljs-keyword">input</span> xor_flag,            <span class="hljs-comment">//指令是否为XOR</span><br>    <span class="hljs-keyword">input</span> nor_flag,            <span class="hljs-comment">//指令是否为NOR</span><br>    <span class="hljs-keyword">input</span> slt_flag,            <span class="hljs-comment">//指令是否为SLT</span><br>    <span class="hljs-keyword">input</span> sltu_flag,           <span class="hljs-comment">//指令是否为SLTU</span><br>    <span class="hljs-keyword">input</span> sll_flag,            <span class="hljs-comment">//指令是否为SLL</span><br>    <span class="hljs-keyword">input</span> srl_flag,            <span class="hljs-comment">//指令是否为SRL</span><br>    <span class="hljs-keyword">input</span> sra_flag,            <span class="hljs-comment">//指令是否为SRA</span><br>    <span class="hljs-keyword">input</span> sllv_flag,           <span class="hljs-comment">//指令是否为SLLV</span><br>    <span class="hljs-keyword">input</span> srlv_flag,           <span class="hljs-comment">//指令是否为SRLV</span><br>    <span class="hljs-keyword">input</span> srav_flag,           <span class="hljs-comment">//指令是否为SRAV</span><br>    <span class="hljs-keyword">input</span> jr_flag,             <span class="hljs-comment">//指令是否为JR</span><br>    <span class="hljs-keyword">input</span> addi_flag,           <span class="hljs-comment">//指令是否为ADDI</span><br>    <span class="hljs-keyword">input</span> addiu_flag,          <span class="hljs-comment">//指令是否为ADDIU</span><br>    <span class="hljs-keyword">input</span> andi_flag,           <span class="hljs-comment">//指令是否为ANDI</span><br>    <span class="hljs-keyword">input</span> ori_flag,            <span class="hljs-comment">//指令是否为ORI</span><br>    <span class="hljs-keyword">input</span> xori_flag,           <span class="hljs-comment">//指令是否为XORI</span><br>    <span class="hljs-keyword">input</span> lw_flag,             <span class="hljs-comment">//指令是否为LW</span><br>    <span class="hljs-keyword">input</span> sw_flag,             <span class="hljs-comment">//指令是否为SW</span><br>    <span class="hljs-keyword">input</span> beq_flag,            <span class="hljs-comment">//指令是否为BEQ</span><br>    <span class="hljs-keyword">input</span> bne_flag,            <span class="hljs-comment">//指令是否为BNE</span><br>    <span class="hljs-keyword">input</span> slti_flag,           <span class="hljs-comment">//指令是否为SLTI</span><br>    <span class="hljs-keyword">input</span> sltiu_flag,          <span class="hljs-comment">//指令是否为SLTIU</span><br>    <span class="hljs-keyword">input</span> lui_flag,            <span class="hljs-comment">//指令是否为LUI</span><br>    <span class="hljs-keyword">input</span> j_flag,              <span class="hljs-comment">//指令是否为J</span><br>    <span class="hljs-keyword">input</span> jal_flag,            <span class="hljs-comment">//指令是否为JAL</span><br>    <span class="hljs-keyword">input</span> zero,                <span class="hljs-comment">//ALU标志位ZF</span><br>    <span class="hljs-comment">/* 所有用到的元件和指令这里都会涉及到 */</span><br>    <span class="hljs-keyword">output</span> reg_w,              <span class="hljs-comment">//RegFile寄存器堆是否可写入</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] aluc,         <span class="hljs-comment">//ALUC的指令，决定ALUC执行何种操作</span><br>    <span class="hljs-keyword">output</span> dm_r,               <span class="hljs-comment">//DMEM是否可写入</span><br>    <span class="hljs-keyword">output</span> dm_w,               <span class="hljs-comment">//是否从DMEM中读取数据</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] ext_ena,      <span class="hljs-comment">//EXT扩展是否开启，5个状态分别对应EXT1、EXT5、EXT16、EXT16(S)、EXT18(S),其中EXT[0]对应EXT1</span><br>    <span class="hljs-keyword">output</span> cat_ena,            <span class="hljs-comment">//是否需要拼接</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">10</span>:<span class="hljs-number">0</span>] mux           <span class="hljs-comment">//10个多路选择器的状态（选择0还是选择1）(0没用到，为了使MUX编号和数组下标对应所以多一个)</span><br>    );<br><span class="hljs-comment">/* 下面是赋值，也就是根据要执行的操作决定各元器件的状态 */</span><br><span class="hljs-keyword">assign</span> reg_w = (!jr_flag &amp;&amp; !sw_flag &amp;&amp; !beq_flag &amp;&amp; !bne_flag &amp;&amp; !j_flag) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><br><span class="hljs-keyword">assign</span> aluc[<span class="hljs-number">3</span>] = (slt_flag  || sltu_flag  || sllv_flag || srlv_flag ||<br>                  srav_flag || sll_flag   || srl_flag  || sra_flag  || <br>                  slti_flag || sltiu_flag || lui_flag) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> aluc[<span class="hljs-number">2</span>] = (and_flag  || or_flag    || xor_flag  || nor_flag  ||<br>                  sllv_flag || srlv_flag  || srav_flag || sll_flag  ||<br>                  srl_flag  || sra_flag   || andi_flag || ori_flag  ||<br>                  xori_flag) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> aluc[<span class="hljs-number">1</span>] = (add_flag  || sub_flag   || xor_flag  || nor_flag  ||<br>                  slt_flag  || sltu_flag  || sllv_flag || sll_flag  ||<br>                  addi_flag || xori_flag  || slti_flag || sltiu_flag) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> aluc[<span class="hljs-number">0</span>] = (sub_flag  || subu_flag  || or_flag   || nor_flag  ||<br>                  slt_flag  || sllv_flag  || srlv_flag || sll_flag  ||<br>                  srl_flag  || ori_flag   || slti_flag || lui_flag  ||<br>                  beq_flag  || bne_flag) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-comment">//aluc[0]中SLLV、SLL、LUI加不加均可</span><br><br><span class="hljs-keyword">assign</span> dm_r = lw_flag ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> dm_w = sw_flag ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><br><span class="hljs-keyword">assign</span> ext_ena[<span class="hljs-number">4</span>] = (beq_flag  || bne_flag) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;                              <span class="hljs-comment">//EXT18(S)</span><br><span class="hljs-keyword">assign</span> ext_ena[<span class="hljs-number">3</span>] = (addi_flag || addiu_flag || lw_flag   || sw_flag ||<br>                     slti_flag || sltiu_flag) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;                            <span class="hljs-comment">//EXT16(S)</span><br><span class="hljs-keyword">assign</span> ext_ena[<span class="hljs-number">2</span>] = (andi_flag || ori_flag   || xori_flag || lui_flag) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;   <span class="hljs-comment">//EXT16</span><br><span class="hljs-keyword">assign</span> ext_ena[<span class="hljs-number">1</span>] = (sll_flag  || srl_flag   || sra_flag) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;                <span class="hljs-comment">//EXT5</span><br><span class="hljs-keyword">assign</span> ext_ena[<span class="hljs-number">0</span>] = (slt_flag  || sltu_flag  || slti_flag || sltiu_flag) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>; <span class="hljs-comment">//EXT1</span><br><br><span class="hljs-keyword">assign</span> cat_ena = (j_flag || jal_flag) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> mux[<span class="hljs-number">10</span>]= (sll_flag   || srl_flag   || sra_flag) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> mux[<span class="hljs-number">9</span>] = (add_flag   || addu_flag  || sub_flag  || subu_flag  ||<br>                 and_flag   || or_flag    || xor_flag  || nor_flag   ||<br>                 sll_flag   || srl_flag   || sra_flag  || sllv_flag  ||<br>                 srlv_flag  || srav_flag  || lui_flag  || addi_flag  || <br>                 addiu_flag || andi_flag  || ori_flag  || xori_flag) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> mux[<span class="hljs-number">8</span>] = (addi_flag  || addiu_flag || lw_flag   || sw_flag    ||<br>                 slti_flag  || sltiu_flag) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> mux[<span class="hljs-number">7</span>] = jal_flag ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> mux[<span class="hljs-number">6</span>] = beq_flag ? ~zero : (bne_flag ? zero : <span class="hljs-number">1&#x27;b1</span>);<br><span class="hljs-keyword">assign</span> mux[<span class="hljs-number">5</span>] = (addi_flag  || addiu_flag || andi_flag || ori_flag  ||<br>                 xori_flag  || lw_flag    || sw_flag   || slti_flag ||<br>                 sltiu_flag || lui_flag) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> mux[<span class="hljs-number">4</span>] = (!jr_flag &amp;&amp; !j_flag &amp;&amp; !jal_flag) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> mux[<span class="hljs-number">3</span>] = (sll_flag   || srl_flag   || sra_flag || sllv_flag || srlv_flag || srav_flag) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> mux[<span class="hljs-number">2</span>] = !lw_flag ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> mux[<span class="hljs-number">1</span>] = (j_flag || jal_flag) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure><h3 id="译码器Decoder"><a href="#译码器Decoder" class="headerlink" title="译码器Decoder"></a>译码器Decoder</h3><p>将指令码转化为控制信号输出。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 1ns / 1ps</span><br><span class="hljs-comment">/* 译码器 */</span><br><span class="hljs-keyword">module</span> Decoder(                 <span class="hljs-comment">//所有接口如果当前译码出的指令不需要，置为高阻抗</span><br>    <span class="hljs-keyword">input</span>  [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] instr_in,     <span class="hljs-comment">//需要译码的指令，也就是当前要执行的指令</span><br>    <span class="hljs-keyword">output</span> add_flag,            <span class="hljs-comment">//指令是否为ADD</span><br>    <span class="hljs-keyword">output</span> addu_flag,           <span class="hljs-comment">//指令是否为ADDU</span><br>    <span class="hljs-keyword">output</span> sub_flag,            <span class="hljs-comment">//指令是否为SUB</span><br>    <span class="hljs-keyword">output</span> subu_flag,           <span class="hljs-comment">//指令是否为SUBU</span><br>    <span class="hljs-keyword">output</span> and_flag,            <span class="hljs-comment">//指令是否为AND</span><br>    <span class="hljs-keyword">output</span> or_flag,             <span class="hljs-comment">//指令是否为OR</span><br>    <span class="hljs-keyword">output</span> xor_flag,            <span class="hljs-comment">//指令是否为XOR</span><br>    <span class="hljs-keyword">output</span> nor_flag,            <span class="hljs-comment">//指令是否为NOR</span><br>    <span class="hljs-keyword">output</span> slt_flag,            <span class="hljs-comment">//指令是否为SLT</span><br>    <span class="hljs-keyword">output</span> sltu_flag,           <span class="hljs-comment">//指令是否为SLTU</span><br>    <span class="hljs-keyword">output</span> sll_flag,            <span class="hljs-comment">//指令是否为SLL</span><br>    <span class="hljs-keyword">output</span> srl_flag,            <span class="hljs-comment">//指令是否为SRL</span><br>    <span class="hljs-keyword">output</span> sra_flag,            <span class="hljs-comment">//指令是否为SRA</span><br>    <span class="hljs-keyword">output</span> sllv_flag,           <span class="hljs-comment">//指令是否为SLLV</span><br>    <span class="hljs-keyword">output</span> srlv_flag,           <span class="hljs-comment">//指令是否为SRLV</span><br>    <span class="hljs-keyword">output</span> srav_flag,           <span class="hljs-comment">//指令是否为SRAV</span><br>    <span class="hljs-keyword">output</span> jr_flag,             <span class="hljs-comment">//指令是否为JR</span><br>    <span class="hljs-keyword">output</span> addi_flag,           <span class="hljs-comment">//指令是否为ADDI</span><br>    <span class="hljs-keyword">output</span> addiu_flag,          <span class="hljs-comment">//指令是否为ADDIU</span><br>    <span class="hljs-keyword">output</span> andi_flag,           <span class="hljs-comment">//指令是否为ANDI</span><br>    <span class="hljs-keyword">output</span> ori_flag,            <span class="hljs-comment">//指令是否为ORI</span><br>    <span class="hljs-keyword">output</span> xori_flag,           <span class="hljs-comment">//指令是否为XORI</span><br>    <span class="hljs-keyword">output</span> lw_flag,             <span class="hljs-comment">//指令是否为LW</span><br>    <span class="hljs-keyword">output</span> sw_flag,             <span class="hljs-comment">//指令是否为SW</span><br>    <span class="hljs-keyword">output</span> beq_flag,            <span class="hljs-comment">//指令是否为BEQ</span><br>    <span class="hljs-keyword">output</span> bne_flag,            <span class="hljs-comment">//指令是否为BNE</span><br>    <span class="hljs-keyword">output</span> slti_flag,           <span class="hljs-comment">//指令是否为SLTI</span><br>    <span class="hljs-keyword">output</span> sltiu_flag,          <span class="hljs-comment">//指令是否为SLTIU</span><br>    <span class="hljs-keyword">output</span> lui_flag,            <span class="hljs-comment">//指令是否为LUI</span><br>    <span class="hljs-keyword">output</span> j_flag,              <span class="hljs-comment">//指令是否为J</span><br>    <span class="hljs-keyword">output</span> jal_flag,            <span class="hljs-comment">//指令是否为JAL</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>]  RsC,          <span class="hljs-comment">//Rs对应的寄存器的地址</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>]  RtC,          <span class="hljs-comment">//Rt对应的寄存器的地址</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>]  RdC,          <span class="hljs-comment">//Rd对应的寄存器的地址</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>]  shamt,        <span class="hljs-comment">//位移偏移量（SLL，SRL，SRA用）</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] immediate,    <span class="hljs-comment">//立即数（I型指令用）</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">25</span>:<span class="hljs-number">0</span>] address       <span class="hljs-comment">//跳转地址（J型指令用）</span><br>    );<br><span class="hljs-comment">/* 定义各指令在原指令中对应的编码 */</span><br><span class="hljs-comment">/* 下面这些指令经过了扩展，OP段全为0，需要额外的6位FUNC加以区分 */</span><br><span class="hljs-keyword">parameter</span> ADD_OPE   = <span class="hljs-number">6&#x27;b100000</span>;<br><span class="hljs-keyword">parameter</span> ADDU_OPE  = <span class="hljs-number">6&#x27;b100001</span>;<br><span class="hljs-keyword">parameter</span> SUB_OPE   = <span class="hljs-number">6&#x27;b100010</span>;<br><span class="hljs-keyword">parameter</span> SUBU_OPE  = <span class="hljs-number">6&#x27;b100011</span>;<br><span class="hljs-keyword">parameter</span> AND_OPE   = <span class="hljs-number">6&#x27;b100100</span>;<br><span class="hljs-keyword">parameter</span> OR_OPE    = <span class="hljs-number">6&#x27;b100101</span>;<br><span class="hljs-keyword">parameter</span> XOR_OPE   = <span class="hljs-number">6&#x27;b100110</span>;<br><span class="hljs-keyword">parameter</span> NOR_OPE   = <span class="hljs-number">6&#x27;b100111</span>;<br><span class="hljs-keyword">parameter</span> SLT_OPE   = <span class="hljs-number">6&#x27;b101010</span>;<br><span class="hljs-keyword">parameter</span> SLTU_OPE  = <span class="hljs-number">6&#x27;b101011</span>;<br><br><span class="hljs-keyword">parameter</span> SLL_OPE   = <span class="hljs-number">6&#x27;b000000</span>;<br><span class="hljs-keyword">parameter</span> SRL_OPE   = <span class="hljs-number">6&#x27;b000010</span>;<br><span class="hljs-keyword">parameter</span> SRA_OPE   = <span class="hljs-number">6&#x27;b000011</span>;<br><br><span class="hljs-keyword">parameter</span> SLLV_OPE  = <span class="hljs-number">6&#x27;b000100</span>;<br><span class="hljs-keyword">parameter</span> SRLV_OPE  = <span class="hljs-number">6&#x27;b000110</span>;<br><span class="hljs-keyword">parameter</span> SRAV_OPE  = <span class="hljs-number">6&#x27;b000111</span>;<br><br><span class="hljs-keyword">parameter</span> JR_OPE    = <span class="hljs-number">6&#x27;b001000</span>;<br><span class="hljs-comment">/* 下面这些指令通过OP段直接加以区分 */</span><br><span class="hljs-keyword">parameter</span> ADDI_OPE  = <span class="hljs-number">6&#x27;b001000</span>;<br><span class="hljs-keyword">parameter</span> ADDIU_OPE = <span class="hljs-number">6&#x27;b001001</span>;<br><span class="hljs-keyword">parameter</span> ANDI_OPE  = <span class="hljs-number">6&#x27;b001100</span>;<br><span class="hljs-keyword">parameter</span> ORI_OPE   = <span class="hljs-number">6&#x27;b001101</span>;<br><span class="hljs-keyword">parameter</span> XORI_OPE  = <span class="hljs-number">6&#x27;b001110</span>;<br><span class="hljs-keyword">parameter</span> LW_OPE    = <span class="hljs-number">6&#x27;b100011</span>;<br><span class="hljs-keyword">parameter</span> SW_OPE    = <span class="hljs-number">6&#x27;b101011</span>;<br><span class="hljs-keyword">parameter</span> BEQ_OPE   = <span class="hljs-number">6&#x27;b000100</span>;<br><span class="hljs-keyword">parameter</span> BNE_OPE   = <span class="hljs-number">6&#x27;b000101</span>;<br><span class="hljs-keyword">parameter</span> SLTI_OPE  = <span class="hljs-number">6&#x27;b001010</span>;<br><span class="hljs-keyword">parameter</span> SLTIU_OPE = <span class="hljs-number">6&#x27;b001011</span>;<br><br><span class="hljs-keyword">parameter</span> LUI_OPE   = <span class="hljs-number">6&#x27;b001111</span>;<br><br><span class="hljs-keyword">parameter</span> J_OPE     = <span class="hljs-number">6&#x27;b000010</span>;<br><span class="hljs-keyword">parameter</span> JAL_OPE   = <span class="hljs-number">6&#x27;b000011</span>;<br><br><span class="hljs-comment">/* 下面是赋值 */</span><br><span class="hljs-comment">/* 对指令进行译码，判断是哪个指令 */</span><br><span class="hljs-keyword">assign</span> add_flag  = ((instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == <span class="hljs-number">6&#x27;h0</span>) &amp;&amp; (instr_in[<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] == ADD_OPE )) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> addu_flag = ((instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == <span class="hljs-number">6&#x27;h0</span>) &amp;&amp; (instr_in[<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] == ADDU_OPE)) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> sub_flag  = ((instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == <span class="hljs-number">6&#x27;h0</span>) &amp;&amp; (instr_in[<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] == SUB_OPE )) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> subu_flag = ((instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == <span class="hljs-number">6&#x27;h0</span>) &amp;&amp; (instr_in[<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] == SUBU_OPE)) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> and_flag  = ((instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == <span class="hljs-number">6&#x27;h0</span>) &amp;&amp; (instr_in[<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] == AND_OPE )) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> or_flag   = ((instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == <span class="hljs-number">6&#x27;h0</span>) &amp;&amp; (instr_in[<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] == OR_OPE  )) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> xor_flag  = ((instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == <span class="hljs-number">6&#x27;h0</span>) &amp;&amp; (instr_in[<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] == XOR_OPE )) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> nor_flag  = ((instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == <span class="hljs-number">6&#x27;h0</span>) &amp;&amp; (instr_in[<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] == NOR_OPE )) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> slt_flag  = ((instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == <span class="hljs-number">6&#x27;h0</span>) &amp;&amp; (instr_in[<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] == SLT_OPE )) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> sltu_flag = ((instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == <span class="hljs-number">6&#x27;h0</span>) &amp;&amp; (instr_in[<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] == SLTU_OPE)) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><br><span class="hljs-keyword">assign</span> sll_flag  = ((instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == <span class="hljs-number">6&#x27;h0</span>) &amp;&amp; (instr_in[<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] == SLL_OPE )) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> srl_flag  = ((instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == <span class="hljs-number">6&#x27;h0</span>) &amp;&amp; (instr_in[<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] == SRL_OPE )) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> sra_flag  = ((instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == <span class="hljs-number">6&#x27;h0</span>) &amp;&amp; (instr_in[<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] == SRA_OPE )) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><br><span class="hljs-keyword">assign</span> sllv_flag = ((instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == <span class="hljs-number">6&#x27;h0</span>) &amp;&amp; (instr_in[<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] == SLLV_OPE)) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> srlv_flag = ((instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == <span class="hljs-number">6&#x27;h0</span>) &amp;&amp; (instr_in[<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] == SRLV_OPE)) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> srav_flag = ((instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == <span class="hljs-number">6&#x27;h0</span>) &amp;&amp; (instr_in[<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] == SRAV_OPE)) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> jr_flag   = ((instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == <span class="hljs-number">6&#x27;h0</span>) &amp;&amp; (instr_in[<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] == JR_OPE  )) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><br><span class="hljs-keyword">assign</span> addi_flag  = (instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == ADDI_OPE ) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> addiu_flag = (instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == ADDIU_OPE) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> andi_flag  = (instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == ANDI_OPE ) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> ori_flag   = (instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == ORI_OPE  ) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> xori_flag  = (instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == XORI_OPE ) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> lw_flag    = (instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == LW_OPE   ) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> sw_flag    = (instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == SW_OPE   ) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> beq_flag   = (instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == BEQ_OPE  ) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> bne_flag   = (instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == BNE_OPE  ) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> slti_flag  = (instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == SLTI_OPE ) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> sltiu_flag = (instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == SLTIU_OPE) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><br><span class="hljs-keyword">assign</span> lui_flag   = (instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == LUI_OPE  ) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><br><span class="hljs-keyword">assign</span> j_flag     = (instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == J_OPE    ) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> jal_flag   = (instr_in[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>] == JAL_OPE  ) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><br><span class="hljs-comment">/* 取出指令中各部分的值 */</span><br><span class="hljs-keyword">assign</span> RsC = (add_flag  || addu_flag || sub_flag  || subu_flag  ||<br>              and_flag  || or_flag   || xor_flag  || nor_flag   ||<br>              slt_flag  || sltu_flag || sllv_flag || srlv_flag  ||<br>              srav_flag || jr_flag   || addi_flag || addiu_flag ||<br>              andi_flag || ori_flag  || xori_flag || lw_flag    ||<br>              sw_flag   || beq_flag  || bne_flag  || slti_flag  ||<br>              sltiu_flag) ? instr_in[<span class="hljs-number">25</span>:<span class="hljs-number">21</span>] : <span class="hljs-number">5&#x27;hz</span>;<br><br><span class="hljs-keyword">assign</span> RtC = (add_flag  || addu_flag  || sub_flag   || subu_flag ||<br>              and_flag  || or_flag    || xor_flag   || nor_flag  ||<br>              slt_flag  || sltu_flag  || sll_flag   || srl_flag  ||<br>              sra_flag  || sllv_flag  || srlv_flag  || srav_flag ||<br>              sw_flag   || beq_flag   || bne_flag ) ? instr_in[<span class="hljs-number">20</span>:<span class="hljs-number">16</span>] : <span class="hljs-number">5&#x27;hz</span>;<br><br><span class="hljs-keyword">assign</span> RdC = (add_flag  || addu_flag  || sub_flag  || subu_flag  ||<br>              and_flag  || or_flag    || xor_flag  || nor_flag   ||<br>              slt_flag  || sltu_flag  || sll_flag  || srl_flag   ||<br>              sra_flag  || sllv_flag  || srlv_flag || srav_flag) ? instr_in[<span class="hljs-number">15</span>:<span class="hljs-number">11</span>] : ((<br>              addi_flag || addiu_flag || andi_flag || ori_flag   || <br>              xori_flag || lw_flag    || slti_flag || sltiu_flag ||<br>              lui_flag) ? instr_in[<span class="hljs-number">20</span>:<span class="hljs-number">16</span>] : (jal_flag ? <span class="hljs-number">5&#x27;d31</span> : <span class="hljs-number">5&#x27;hz</span>));<br><br><span class="hljs-keyword">assign</span> shamt = (sll_flag || srl_flag || sra_flag) ? instr_in[<span class="hljs-number">10</span>:<span class="hljs-number">6</span>] : <span class="hljs-number">5&#x27;hz</span>;        <br><br><span class="hljs-keyword">assign</span> immediate = (addi_flag || addiu_flag || andi_flag  || ori_flag || <br>                    xori_flag || lw_flag    || sw_flag    || beq_flag || <br>                    bne_flag  || slti_flag  || sltiu_flag || lui_flag) ? instr_in[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] : <span class="hljs-number">16&#x27;hz</span>;<br><br><span class="hljs-keyword">assign</span> address = (j_flag || jal_flag) ? instr_in[<span class="hljs-number">25</span>:<span class="hljs-number">0</span>] : <span class="hljs-number">26&#x27;hz</span>;     <br><br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure><h3 id="算术逻辑单元ALU"><a href="#算术逻辑单元ALU" class="headerlink" title="算术逻辑单元ALU"></a>算术逻辑单元ALU</h3><p>完成各种算术和逻辑运算</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 1ns / 1ps</span><br><span class="hljs-comment">/* 算术逻辑单元 */</span><br><span class="hljs-keyword">module</span> ALU(<br>    <span class="hljs-keyword">input</span>  [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] ALU_C,          <span class="hljs-comment">//操作指令</span><br>    <span class="hljs-keyword">input</span>  [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] A,             <span class="hljs-comment">//接口A</span><br>    <span class="hljs-keyword">input</span>  [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] B,             <span class="hljs-comment">//接口B</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] OUT,           <span class="hljs-comment">//运算结果</span><br>    <span class="hljs-comment">/* 运算标志位 */</span><br>    <span class="hljs-keyword">output</span> CF,<br>    <span class="hljs-keyword">output</span> ZF,<br>    <span class="hljs-keyword">output</span> SF,<br>    <span class="hljs-keyword">output</span> OF<br>    );<br>    <span class="hljs-comment">/* 定义各指令对应的操作 */</span><br>    <span class="hljs-keyword">parameter</span> ADD  = <span class="hljs-number">4&#x27;b0000</span>;<span class="hljs-comment">//有符号加</span><br>    <span class="hljs-keyword">parameter</span> ADDU = <span class="hljs-number">4&#x27;b0010</span>;<span class="hljs-comment">//无符号加</span><br>    <span class="hljs-keyword">parameter</span> SUB  = <span class="hljs-number">4&#x27;b0001</span>;<span class="hljs-comment">//有符号键</span><br>    <span class="hljs-keyword">parameter</span> SUBU = <span class="hljs-number">4&#x27;b0011</span>;<span class="hljs-comment">//无符号减</span><br>    <span class="hljs-keyword">parameter</span> AND  = <span class="hljs-number">4&#x27;b0100</span>;<span class="hljs-comment">//按位与</span><br>    <span class="hljs-keyword">parameter</span> OR   = <span class="hljs-number">4&#x27;b0101</span>;<span class="hljs-comment">//按位或</span><br>    <span class="hljs-keyword">parameter</span> XOR  = <span class="hljs-number">4&#x27;b0110</span>;<span class="hljs-comment">//按位异或</span><br>    <span class="hljs-keyword">parameter</span> NOR  = <span class="hljs-number">4&#x27;b0111</span>;<span class="hljs-comment">//安慰或非</span><br>    <span class="hljs-keyword">parameter</span> LUI  = <span class="hljs-number">4&#x27;b100x</span>;<span class="hljs-comment">//加载无符号立即数</span><br>    <span class="hljs-keyword">parameter</span> SLT  = <span class="hljs-number">4&#x27;b1011</span>;<span class="hljs-comment">//小于</span><br>    <span class="hljs-keyword">parameter</span> SLTU = <span class="hljs-number">4&#x27;b1010</span>;<span class="hljs-comment">//无符号小于</span><br>    <span class="hljs-keyword">parameter</span> SRA  = <span class="hljs-number">4&#x27;b1100</span>;<span class="hljs-comment">//算术右移</span><br>    <span class="hljs-keyword">parameter</span> SLL  = <span class="hljs-number">4&#x27;b111x</span>;<span class="hljs-comment">//逻辑右移</span><br>    <span class="hljs-keyword">parameter</span> SLA  = <span class="hljs-number">4&#x27;b111x</span>;<span class="hljs-comment">//算术左移</span><br>    <span class="hljs-keyword">parameter</span> SRL  = <span class="hljs-number">4&#x27;b1101</span>;<span class="hljs-comment">//逻辑左移</span><br>    <span class="hljs-comment">/* 定义一些内部用的变量 */</span><br>    <span class="hljs-keyword">reg</span> [<span class="hljs-number">32</span>:<span class="hljs-number">0</span>] result;          <span class="hljs-comment">//存储结果，result[32]为进位判断</span><br>    <span class="hljs-keyword">wire</span> <span class="hljs-keyword">signed</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] s_A,s_B; <span class="hljs-comment">//有符号数</span><br>    <span class="hljs-keyword">assign</span> s_A = A;<br>    <span class="hljs-keyword">assign</span> s_B = B;<br>    <br>    <span class="hljs-keyword">always</span> @(*)<br>    <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">case</span>(ALU_C)<br>            ADD:        <span class="hljs-keyword">begin</span> result &lt;= s_A + s_B;                      <span class="hljs-keyword">end</span> <br>            ADDU:       <span class="hljs-keyword">begin</span> result &lt;= A + B;                          <span class="hljs-keyword">end</span><br>            SUB:        <span class="hljs-keyword">begin</span> result &lt;= s_A - s_B;                      <span class="hljs-keyword">end</span><br>            SUBU:       <span class="hljs-keyword">begin</span> result &lt;= A - B;                          <span class="hljs-keyword">end</span><br>            AND:        <span class="hljs-keyword">begin</span> result &lt;= A &amp; B;                          <span class="hljs-keyword">end</span><br>            OR:         <span class="hljs-keyword">begin</span> result &lt;= A | B;                          <span class="hljs-keyword">end</span><br>            XOR:        <span class="hljs-keyword">begin</span> result &lt;= A ^ B;                          <span class="hljs-keyword">end</span><br>            NOR:        <span class="hljs-keyword">begin</span> result &lt;= ~(A | B);                       <span class="hljs-keyword">end</span><br>            LUI:        <span class="hljs-keyword">begin</span> result &lt;= &#123; B[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] , <span class="hljs-number">16&#x27;b0</span> &#125;;            <span class="hljs-keyword">end</span><br>            SLT:        <span class="hljs-keyword">begin</span> result &lt;= s_A - s_B;                      <span class="hljs-keyword">end</span><br>            SLTU:       <span class="hljs-keyword">begin</span> result &lt;= A - B;                          <span class="hljs-keyword">end</span><br>            SRA:        <span class="hljs-keyword">begin</span> result &lt;= s_B &gt;&gt;&gt; s_A;                    <span class="hljs-keyword">end</span><br>            SLL,SLA:    <span class="hljs-keyword">begin</span> result &lt;= B &lt;&lt; A;                         <span class="hljs-keyword">end</span><br>            SRL:        <span class="hljs-keyword">begin</span> result &lt;= B &gt;&gt; A;                         <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">endcase</span><br>    <span class="hljs-keyword">end</span> <br>    <br>    <span class="hljs-keyword">assign</span> OUT = result[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>];              <span class="hljs-comment">//运算结果</span><br>    <span class="hljs-keyword">assign</span> CF =  result[<span class="hljs-number">32</span>];                <span class="hljs-comment">//进位标志位</span><br>    <span class="hljs-keyword">assign</span> ZF = (result == <span class="hljs-number">32&#x27;b0</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;  <span class="hljs-comment">//0标志位</span><br>    <span class="hljs-keyword">assign</span> SF = (ALU_C == SLT ? (s_A &lt; s_B):<span class="hljs-comment">//有符号数比较</span><br>                 ((ALU_C == SLTU) ? (A &lt; B):<span class="hljs-comment">//无符号数比较</span><br>                                     <span class="hljs-number">1&#x27;b0</span>));<span class="hljs-comment">//0</span><br>    <span class="hljs-keyword">assign</span> OF = result[<span class="hljs-number">32</span>];                 <span class="hljs-comment">//溢出标志位</span><br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure><h3 id="寄存器堆Regfile"><a href="#寄存器堆Regfile" class="headerlink" title="寄存器堆Regfile"></a>寄存器堆Regfile</h3><p>32位的寄存器堆</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 1ns / 1ps</span><br><span class="hljs-comment">/* 寄存器堆 */</span><br><span class="hljs-keyword">module</span> regfile(               <br>    <span class="hljs-keyword">input</span>  reg_clk,      <span class="hljs-comment">//时钟 </span><br>    <span class="hljs-keyword">input</span>  reg_ena,      <span class="hljs-comment">//使能     </span><br>    <span class="hljs-keyword">input</span>  rst_n,        <span class="hljs-comment">//清零     </span><br>    <span class="hljs-keyword">input</span>  reg_w,        <span class="hljs-comment">//写入</span><br>    <span class="hljs-keyword">input</span>  [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] RdC,    <span class="hljs-comment">//目标寄存器</span><br>    <span class="hljs-keyword">input</span>  [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] RtC,         <br>    <span class="hljs-keyword">input</span>  [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] RsC,    <span class="hljs-comment">//源寄存器  </span><br>    <span class="hljs-keyword">input</span>  [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] Rd_data_in, <br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] Rs_data_out,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] Rt_data_out <br>);<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] array_reg [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>];<br><span class="hljs-keyword">assign</span> Rs_data_out = reg_ena ? array_reg[RsC] : <span class="hljs-number">32&#x27;bz</span>;<br><span class="hljs-keyword">assign</span> Rt_data_out = reg_ena ? array_reg[RtC] : <span class="hljs-number">32&#x27;bz</span>;<br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">negedge</span> reg_clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst_n)<br><span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span>(rst_n &amp;&amp; reg_ena)<br>    <span class="hljs-keyword">begin</span><br>        array_reg[<span class="hljs-number">0</span>]  &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">1</span>]  &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">2</span>]  &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">3</span>]  &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">4</span>]  &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">5</span>]  &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">6</span>]  &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">7</span>]  &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">8</span>]  &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">9</span>]  &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">10</span>] &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">11</span>] &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">12</span>] &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">13</span>] &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">14</span>] &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">15</span>] &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">16</span>] &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">17</span>] &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">18</span>] &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">19</span>] &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">20</span>] &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">21</span>] &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">22</span>] &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">23</span>] &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">24</span>] &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">25</span>] &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">26</span>] &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">27</span>] &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">28</span>] &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">29</span>] &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">30</span>] &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>        array_reg[<span class="hljs-number">31</span>] &lt;= <span class="hljs-number">32&#x27;h0</span>;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg_ena &amp;&amp; reg_w &amp;&amp; (RdC != <span class="hljs-number">5&#x27;h0</span>))<br>        array_reg[RdC] &lt;= Rd_data_in;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h3 id="程序计数器PC"><a href="#程序计数器PC" class="headerlink" title="程序计数器PC"></a>程序计数器PC</h3><p>存储指令地址</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 1ns / 1ps</span><br><span class="hljs-comment">/* 程序计数器 */</span><br><span class="hljs-keyword">module</span> PC(                    <br>    <span class="hljs-keyword">input</span>  pc_clk,  <span class="hljs-comment">//时钟信号            </span><br>    <span class="hljs-keyword">input</span>  pc_ena,  <span class="hljs-comment">//使能信号            </span><br>    <span class="hljs-keyword">input</span>  rst_n,   <span class="hljs-comment">//重置信号            </span><br>    <span class="hljs-keyword">input</span>  [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] pc_addr_in, <span class="hljs-comment">//读入指令地址</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] pc_addr_out <span class="hljs-comment">//输出到IMEM</span><br>    );<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] pc_reg = <span class="hljs-number">32&#x27;h00400000</span>;<span class="hljs-comment">//MARS地址初值</span><br><span class="hljs-keyword">assign</span> pc_addr_out = pc_ena ? pc_reg : <span class="hljs-number">32&#x27;hz</span>;<br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">negedge</span> pc_clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> rst_n)<br><span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span>(rst_n &amp;&amp; pc_ena)<span class="hljs-keyword">begin</span><br>        pc_reg = <span class="hljs-number">32&#x27;h00400000</span>;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pc_ena)<span class="hljs-keyword">begin</span><br>        pc_reg = pc_addr_in;<br>        <span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>负责调用PC，Controller等模块</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 1ns / 1ps</span><br><span class="hljs-keyword">module</span> cpu(<br>    <span class="hljs-keyword">input</span> clk,                  <span class="hljs-comment">//CPU执行时钟</span><br>    <span class="hljs-keyword">input</span> ena,                  <span class="hljs-comment">//使能信号端</span><br>    <span class="hljs-keyword">input</span> rst_n,                <span class="hljs-comment">//复位信号</span><br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] instr_in,      <span class="hljs-comment">//当前要执行的指令</span><br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] dm_data,       <span class="hljs-comment">//读取到的DMEM的具体内容</span><br>    <span class="hljs-keyword">output</span> dm_ena,              <span class="hljs-comment">//是否需要启用DMEM</span><br>    <span class="hljs-keyword">output</span> dm_w,                <span class="hljs-comment">//如果启用DMEM，是否为写入</span><br>    <span class="hljs-keyword">output</span> dm_r,                <span class="hljs-comment">//如果启用DMEM，是否为读取</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] pc_out,       <span class="hljs-comment">//输出指令地址，告诉IMEM要取哪条</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] dm_addr,      <span class="hljs-comment">//启用DMEM的地址</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] dm_data_w     <span class="hljs-comment">//要写入DMEM的内容 </span><br>    );<br><span class="hljs-comment">/* 定义一些内部变量 */</span><br><span class="hljs-comment">/* Decoder用 */</span><br><span class="hljs-keyword">wire</span> add_flag,  addu_flag, sub_flag, subu_flag, and_flag, or_flag, xor_flag, nor_flag,<br>     slt_flag,  sltu_flag,<br>     sll_flag,  srl_flag,  sra_flag, sllv_flag,<br>     srlv_flag, srav_flag,<br>     jr_flag,<br>     addi_flag, addiu_flag,<br>     andi_flag, ori_flag,  xori_flag,<br>     lw_flag,   sw_flag,<br>     beq_flag,  bne_flag,<br>     slti_flag, sltiu_flag,<br>     lui_flag,<br>     j_flag,    jal_flag;       <span class="hljs-comment">//各个指令的标志信息</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] RsC;                 <span class="hljs-comment">//Rs对应的寄存器的地址</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] RtC;                 <span class="hljs-comment">//Rt对应的寄存器的地址</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] RdC;                 <span class="hljs-comment">//Rd对应的寄存器的地址</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] shamt;               <span class="hljs-comment">//位移偏移量（SLL，SRL，SRA用）</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] immediate;          <span class="hljs-comment">//立即数（I型指令用）</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">25</span>:<span class="hljs-number">0</span>] address;            <span class="hljs-comment">//跳转地址（J型指令用）</span><br><br><span class="hljs-comment">/* Control用 */</span><br><span class="hljs-keyword">wire</span> reg_w;                     <span class="hljs-comment">//RegFile寄存器堆是否可写入</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">9</span>:<span class="hljs-number">0</span>] mux;                 <span class="hljs-comment">//9个多路选择器的状态</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] ext_ena;             <span class="hljs-comment">//EXT扩展是否开启，5个状态分别对应EXT1、EXT5、EXT16、EXT16(S)、EXT18(S),其中EXT[0]对应EXT1</span><br><span class="hljs-keyword">wire</span> cat_ena;                   <span class="hljs-comment">//是否需要拼接</span><br><br><span class="hljs-comment">/* ALU用 */</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] a, b;                              <span class="hljs-comment">//ALU的A、B运算输入端</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]  aluc;                       <span class="hljs-comment">//ALUC四位运算指令</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] alu_data_out;               <span class="hljs-comment">//ALU输出的数据</span><br><span class="hljs-keyword">wire</span> zero, carry, negative, overflow;   <span class="hljs-comment">//四个标志位</span><br><br><span class="hljs-comment">/* 寄存器堆RegFile用 */</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] Rd_data_in;     <span class="hljs-comment">//要向寄存器中写入的值</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] Rs_data_out;    <span class="hljs-comment">//Rs对应的寄存器的输出值</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] Rt_data_out;    <span class="hljs-comment">//Rt对应的寄存器的输出值</span><br><br><span class="hljs-comment">/* PC寄存器用 */</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] pc_addr_in;     <span class="hljs-comment">//本次输入PC寄存器的指令地址，也就是下一次要执行的指令</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] pc_addr_out;    <span class="hljs-comment">//本次从PC寄存器中传出的指令地址，也就是当前需要执行的指令</span><br><br><span class="hljs-comment">/* 连接各模块 */</span><br><span class="hljs-comment">/* 符号、数据扩展器线路 */</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ext1_out;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ext5_out;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ext16_out;<br><span class="hljs-keyword">wire</span> <span class="hljs-keyword">signed</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ext16_out_signed;<br><span class="hljs-keyword">wire</span> <span class="hljs-keyword">signed</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ext18_out_signed;<br><br><span class="hljs-keyword">assign</span> ext1_out         = (slt_flag  || sltu_flag) ? negative : (slti_flag || sltiu_flag) ? carry : <span class="hljs-number">32&#x27;hz</span>;<br><span class="hljs-keyword">assign</span> ext5_out         = (sll_flag  || srl_flag   || sra_flag ||sllv_flag||srlv_flag||srav_flag) ? mux10_out : <span class="hljs-number">32&#x27;hz</span>;<br><span class="hljs-keyword">assign</span> ext16_out        = (andi_flag || ori_flag   || xori_flag || lui_flag) ? &#123; <span class="hljs-number">16&#x27;h0</span> , immediate[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] &#125; : <span class="hljs-number">32&#x27;hz</span>;<br><span class="hljs-keyword">assign</span> ext16_out_signed = (addi_flag || addiu_flag || lw_flag || sw_flag || slti_flag || sltiu_flag) ?  &#123; &#123;<span class="hljs-number">16</span>&#123;immediate[<span class="hljs-number">15</span>]&#125;&#125; , immediate[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] &#125; : <span class="hljs-number">32&#x27;hz</span>;<br><span class="hljs-keyword">assign</span> ext18_out_signed = (beq_flag  || bne_flag) ? &#123;&#123;<span class="hljs-number">14</span>&#123;immediate[<span class="hljs-number">15</span>]&#125;&#125;, immediate[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>], <span class="hljs-number">2&#x27;b0</span>&#125; : <span class="hljs-number">32&#x27;hz</span>;<br><span class="hljs-comment">//注意：Verilog不会显式地将无符号数变为有符号数，只有在运算时才会进行操作。因此我们不能通过赋值的方法完成从无符号数到有符号数的扩展，必须将符号位复制到高位</span><br><br><span class="hljs-comment">/* ||拼接器线路 */</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] cat_out;<br><br><span class="hljs-keyword">assign</span> cat_out = cat_ena ? &#123;pc_out[<span class="hljs-number">31</span>:<span class="hljs-number">28</span>], address[<span class="hljs-number">25</span>:<span class="hljs-number">0</span>], <span class="hljs-number">2&#x27;h0</span>&#125; : <span class="hljs-number">32&#x27;hz</span>;<br><br><span class="hljs-comment">/* NPC线路 */</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] npc;<br><span class="hljs-keyword">assign</span> npc = pc_addr_out + <span class="hljs-number">4</span>;<br><br><span class="hljs-comment">/* 多路选择器线路 */</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] mux1_out;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] mux2_out;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] mux3_out;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] mux4_out;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] mux5_out;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] mux6_out;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] mux7_out;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] mux8_out;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] mux9_out;<br><br><span class="hljs-keyword">assign</span> mux1_out = mux[<span class="hljs-number">1</span>] ? cat_out          : mux4_out;<br><span class="hljs-keyword">assign</span> mux2_out = mux[<span class="hljs-number">2</span>] ? mux9_out         : dm_data;<br><span class="hljs-keyword">assign</span> mux3_out = mux[<span class="hljs-number">3</span>] ? ext5_out         : Rs_data_out;<br><span class="hljs-keyword">assign</span> mux4_out = mux[<span class="hljs-number">4</span>] ? mux6_out         : Rs_data_out;<br><span class="hljs-keyword">assign</span> mux5_out = mux[<span class="hljs-number">5</span>] ? mux8_out         : Rt_data_out;<br><span class="hljs-keyword">assign</span> mux6_out = mux[<span class="hljs-number">6</span>] ? npc              : ext18_out_signed + npc;<br><span class="hljs-keyword">assign</span> mux7_out = mux[<span class="hljs-number">7</span>] ? pc_addr_out + <span class="hljs-number">4</span>  : mux2_out;<br><span class="hljs-keyword">assign</span> mux8_out = mux[<span class="hljs-number">8</span>] ? ext16_out_signed : ext16_out;<br><span class="hljs-keyword">assign</span> mux9_out = mux[<span class="hljs-number">9</span>] ? alu_data_out     : ext1_out;<br><span class="hljs-keyword">assign</span> mux10_out= mux[<span class="hljs-number">10</span>]? Rs_data_out[<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] : shamt;<br><br><span class="hljs-comment">/* PC线路 */</span><br><span class="hljs-keyword">assign</span> pc_addr_in = mux1_out;<br><br><span class="hljs-comment">/* ALU 接线口 */</span><br><span class="hljs-keyword">assign</span> a = mux3_out;<br><span class="hljs-keyword">assign</span> b = mux5_out;<br><br><span class="hljs-comment">/* IMEM接口 */</span><br><span class="hljs-keyword">assign</span> pc_out = pc_addr_out;<br><br><span class="hljs-comment">/* DMEM接口 */</span><br><span class="hljs-keyword">assign</span> dm_ena  = (dm_r || dm_w) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> dm_addr = alu_data_out;<br><span class="hljs-keyword">assign</span> dm_data_w = Rt_data_out;<br><br><span class="hljs-comment">/* 寄存器堆线路 */</span><br><span class="hljs-keyword">assign</span> Rd_data_in = mux7_out;<br><br><span class="hljs-comment">/* 实例化译码器 */</span><br>Decoder Decoder_inst(<br>    <span class="hljs-variable">.instr_in</span>(instr_in),        <span class="hljs-comment">//需要译码的指令，也就是当前要执行的指令</span><br>    <span class="hljs-variable">.add_flag</span>(add_flag),        <span class="hljs-comment">//指令是否为ADD</span><br>    <span class="hljs-variable">.addu_flag</span>(addu_flag),      <span class="hljs-comment">//指令是否为ADDU</span><br>    <span class="hljs-variable">.sub_flag</span>(sub_flag),        <span class="hljs-comment">//指令是否为SUB</span><br>    <span class="hljs-variable">.subu_flag</span>(subu_flag),      <span class="hljs-comment">//指令是否为SUBU</span><br>    <span class="hljs-variable">.and_flag</span>(and_flag),        <span class="hljs-comment">//指令是否为AND</span><br>    <span class="hljs-variable">.or_flag</span>(or_flag),          <span class="hljs-comment">//指令是否为OR</span><br>    <span class="hljs-variable">.xor_flag</span>(xor_flag),        <span class="hljs-comment">//指令是否为XOR</span><br>    <span class="hljs-variable">.nor_flag</span>(nor_flag),        <span class="hljs-comment">//指令是否为NOR</span><br>    <span class="hljs-variable">.slt_flag</span>(slt_flag),        <span class="hljs-comment">//指令是否为SLT</span><br>    <span class="hljs-variable">.sltu_flag</span>(sltu_flag),      <span class="hljs-comment">//指令是否为SLTU</span><br>    <span class="hljs-variable">.sll_flag</span>(sll_flag) ,       <span class="hljs-comment">//指令是否为SLL</span><br>    <span class="hljs-variable">.srl_flag</span>(srl_flag),        <span class="hljs-comment">//指令是否为SRL</span><br>    <span class="hljs-variable">.sra_flag</span>(sra_flag),        <span class="hljs-comment">//指令是否为SRA</span><br>    <span class="hljs-variable">.sllv_flag</span>(sllv_flag),      <span class="hljs-comment">//指令是否为SLLV</span><br>    <span class="hljs-variable">.srlv_flag</span>(srlv_flag),      <span class="hljs-comment">//指令是否为SRLV</span><br>    <span class="hljs-variable">.srav_flag</span>(srav_flag),      <span class="hljs-comment">//指令是否为SRAV</span><br>    <span class="hljs-variable">.jr_flag</span>(jr_flag),          <span class="hljs-comment">//指令是否为JR</span><br>    <span class="hljs-variable">.addi_flag</span>(addi_flag),      <span class="hljs-comment">//指令是否为ADDI</span><br>    <span class="hljs-variable">.addiu_flag</span>(addiu_flag),    <span class="hljs-comment">//指令是否为ADDIU</span><br>    <span class="hljs-variable">.andi_flag</span>(andi_flag),      <span class="hljs-comment">//指令是否为ANDI</span><br>    <span class="hljs-variable">.ori_flag</span>(ori_flag),        <span class="hljs-comment">//指令是否为ORI</span><br>    <span class="hljs-variable">.xori_flag</span>(xori_flag),      <span class="hljs-comment">//指令是否为XORI</span><br>    <span class="hljs-variable">.lw_flag</span>(lw_flag),          <span class="hljs-comment">//指令是否为LW</span><br>    <span class="hljs-variable">.sw_flag</span>(sw_flag),          <span class="hljs-comment">//指令是否为SW</span><br>    <span class="hljs-variable">.beq_flag</span>(beq_flag),        <span class="hljs-comment">//指令是否为BEQ</span><br>    <span class="hljs-variable">.bne_flag</span>(bne_flag),        <span class="hljs-comment">//指令是否为BNE</span><br>    <span class="hljs-variable">.slti_flag</span>(slti_flag),      <span class="hljs-comment">//指令是否为SLTI</span><br>    <span class="hljs-variable">.sltiu_flag</span>(sltiu_flag),    <span class="hljs-comment">//指令是否为SLTIU</span><br>    <span class="hljs-variable">.lui_flag</span>(lui_flag),        <span class="hljs-comment">//指令是否为LUI</span><br>    <span class="hljs-variable">.j_flag</span>(j_flag),            <span class="hljs-comment">//指令是否为J</span><br>    <span class="hljs-variable">.jal_flag</span>(jal_flag),        <span class="hljs-comment">//指令是否为JAL</span><br>    <span class="hljs-variable">.RsC</span>(RsC),                  <span class="hljs-comment">//Rs对应的寄存器的地址</span><br>    <span class="hljs-variable">.RtC</span>(RtC),                  <span class="hljs-comment">//Rt对应的寄存器的地址</span><br>    <span class="hljs-variable">.RdC</span>(RdC),                  <span class="hljs-comment">//Rd对应的寄存器的地址</span><br>    <span class="hljs-variable">.shamt</span>(shamt),              <span class="hljs-comment">//位移偏移量（SLL，SRL，SRA用）</span><br>    <span class="hljs-variable">.immediate</span>(immediate),      <span class="hljs-comment">//立即数（I型指令用）</span><br>    <span class="hljs-variable">.address</span>(address)           <span class="hljs-comment">//跳转地址（J型指令用）</span><br>    );<br><br><span class="hljs-comment">/* 实例化控制器 */</span><br>Controler Controler_inst(              <br>    <span class="hljs-variable">.add_flag</span>(add_flag),        <span class="hljs-comment">//指令是否为ADD</span><br>    <span class="hljs-variable">.addu_flag</span>(addu_flag),      <span class="hljs-comment">//指令是否为ADDU</span><br>    <span class="hljs-variable">.sub_flag</span>(sub_flag),        <span class="hljs-comment">//指令是否为SUB</span><br>    <span class="hljs-variable">.subu_flag</span>(subu_flag),      <span class="hljs-comment">//指令是否为SUBU</span><br>    <span class="hljs-variable">.and_flag</span>(and_flag),        <span class="hljs-comment">//指令是否为AND</span><br>    <span class="hljs-variable">.or_flag</span>(or_flag),          <span class="hljs-comment">//指令是否为OR</span><br>    <span class="hljs-variable">.xor_flag</span>(xor_flag),        <span class="hljs-comment">//指令是否为XOR</span><br>    <span class="hljs-variable">.nor_flag</span>(nor_flag),        <span class="hljs-comment">//指令是否为NOR</span><br>    <span class="hljs-variable">.slt_flag</span>(slt_flag),        <span class="hljs-comment">//指令是否为SLT</span><br>    <span class="hljs-variable">.sltu_flag</span>(sltu_flag),      <span class="hljs-comment">//指令是否为SLTU</span><br>    <span class="hljs-variable">.sll_flag</span>(sll_flag) ,       <span class="hljs-comment">//指令是否为SLL</span><br>    <span class="hljs-variable">.srl_flag</span>(srl_flag),        <span class="hljs-comment">//指令是否为SRL</span><br>    <span class="hljs-variable">.sra_flag</span>(sra_flag),        <span class="hljs-comment">//指令是否为SRA</span><br>    <span class="hljs-variable">.sllv_flag</span>(sllv_flag),      <span class="hljs-comment">//指令是否为SLLV</span><br>    <span class="hljs-variable">.srlv_flag</span>(srlv_flag),      <span class="hljs-comment">//指令是否为SRLV</span><br>    <span class="hljs-variable">.srav_flag</span>(srav_flag),      <span class="hljs-comment">//指令是否为SRAV</span><br>    <span class="hljs-variable">.jr_flag</span>(jr_flag),          <span class="hljs-comment">//指令是否为JR</span><br>    <span class="hljs-variable">.addi_flag</span>(addi_flag),      <span class="hljs-comment">//指令是否为ADDI</span><br>    <span class="hljs-variable">.addiu_flag</span>(addiu_flag),    <span class="hljs-comment">//指令是否为ADDIU</span><br>    <span class="hljs-variable">.andi_flag</span>(andi_flag),      <span class="hljs-comment">//指令是否为ANDI</span><br>    <span class="hljs-variable">.ori_flag</span>(ori_flag),        <span class="hljs-comment">//指令是否为ORI</span><br>    <span class="hljs-variable">.xori_flag</span>(xori_flag),      <span class="hljs-comment">//指令是否为XORI</span><br>    <span class="hljs-variable">.lw_flag</span>(lw_flag),          <span class="hljs-comment">//指令是否为LW</span><br>    <span class="hljs-variable">.sw_flag</span>(sw_flag),          <span class="hljs-comment">//指令是否为SW</span><br>    <span class="hljs-variable">.beq_flag</span>(beq_flag),        <span class="hljs-comment">//指令是否为BEQ</span><br>    <span class="hljs-variable">.bne_flag</span>(bne_flag),        <span class="hljs-comment">//指令是否为BNE</span><br>    <span class="hljs-variable">.slti_flag</span>(slti_flag),      <span class="hljs-comment">//指令是否为SLTI</span><br>    <span class="hljs-variable">.sltiu_flag</span>(sltiu_flag),    <span class="hljs-comment">//指令是否为SLTIU</span><br>    <span class="hljs-variable">.lui_flag</span>(lui_flag),        <span class="hljs-comment">//指令是否为LUI</span><br>    <span class="hljs-variable">.j_flag</span>(j_flag),            <span class="hljs-comment">//指令是否为J</span><br>    <span class="hljs-variable">.jal_flag</span>(jal_flag),        <span class="hljs-comment">//指令是否为JAL</span><br>    <span class="hljs-variable">.zero</span>(zero),                <span class="hljs-comment">//ALU标志位ZF</span><br>    <span class="hljs-variable">.reg_w</span>(reg_w),              <span class="hljs-comment">//RegFile寄存器堆是否可写入</span><br>    <span class="hljs-variable">.aluc</span>(aluc),                <span class="hljs-comment">//ALUC的指令，决定ALUC执行何种操作</span><br>    <span class="hljs-variable">.dm_r</span>(dm_r),                <span class="hljs-comment">//DMEM是否可写入</span><br>    <span class="hljs-variable">.dm_w</span>(dm_w),                <span class="hljs-comment">//是否从DMEM中读取数据</span><br>    <span class="hljs-variable">.ext_ena</span>(ext_ena),          <span class="hljs-comment">//EXT扩展是否开启，5个状态分别对应EXT1、EXT5、EXT16、EXT16(S)、EXT18(S),其中EXT[0]对应EXT1</span><br>    <span class="hljs-variable">.cat_ena</span>(cat_ena),          <span class="hljs-comment">//是否需要拼接</span><br>    <span class="hljs-variable">.mux</span>(mux)                   <span class="hljs-comment">//9个多路选择器的状态（选择0还是选择1）(0没用到，为了使MUX编号和数组下标对应所以多一个)</span><br>    );<br><br><span class="hljs-comment">/* 实例化ALU */</span><br>ALU ALU_inst(                      <br>    <span class="hljs-variable">.A</span>(a),                      <span class="hljs-comment">//对应A接口</span><br>    <span class="hljs-variable">.B</span>(b),                      <span class="hljs-comment">//对应B接口</span><br>    <span class="hljs-variable">.ALU_C</span>(aluc),                <span class="hljs-comment">//ALUC四位操作指令</span><br>    <span class="hljs-variable">.OUT</span>(alu_data_out),<span class="hljs-comment">//输出数据</span><br>    <span class="hljs-variable">.ZF</span>(zero),                <span class="hljs-comment">//ZF标志位，BEQ/BNE使用</span><br>    <span class="hljs-variable">.CF</span>(carry),              <span class="hljs-comment">//CF标志位，SLTI/SLTIU使用</span><br>    <span class="hljs-variable">.SF</span>(negative),        <span class="hljs-comment">//NF(SF)标志位，SLT/SLTU使用</span><br>    <span class="hljs-variable">.OF</span>(overflow)         <span class="hljs-comment">//OF标志位，其实没有用到</span><br>    );<br><br><span class="hljs-comment">/* 实例化寄存器堆 */</span><br>regfile cpu_ref(                <span class="hljs-comment">//寄存器堆RegFile，写入为同步，读取为异步</span><br>    <span class="hljs-variable">.reg_clk</span>(clk),              <span class="hljs-comment">//时钟信号，下降沿有效</span><br>    <span class="hljs-variable">.reg_ena</span>(ena),              <span class="hljs-comment">//使能信号端，上升沿有效</span><br>    <span class="hljs-variable">.rst_n</span>(rst_n),              <span class="hljs-comment">//复位信号，高电平有效（检测上升沿）</span><br>    <span class="hljs-variable">.reg_w</span>(reg_w),              <span class="hljs-comment">//写信号，高电平时寄存器可写入，低电平不可写入</span><br>    <span class="hljs-variable">.RdC</span>(RdC),                  <span class="hljs-comment">//Rd对应的寄存器的地址（写入端）</span><br>    <span class="hljs-variable">.RtC</span>(RtC),                  <span class="hljs-comment">//Rt对应的寄存器的地址（输出端）</span><br>    <span class="hljs-variable">.RsC</span>(RsC),                  <span class="hljs-comment">//Rs对应的寄存器的地址（输出端）</span><br>    <span class="hljs-variable">.Rd_data_in</span>(Rd_data_in),    <span class="hljs-comment">//要向寄存器中写入的值（需拉高reg_w）</span><br>    <span class="hljs-variable">.Rs_data_out</span>(Rs_data_out),  <span class="hljs-comment">//Rs对应的寄存器的输出值</span><br>    <span class="hljs-variable">.Rt_data_out</span>(Rt_data_out)   <span class="hljs-comment">//Rt对应的寄存器的输出值</span><br>    );<br><br><span class="hljs-comment">/* 实例化PC寄存器 */</span><br>PC PC_inst(                     <span class="hljs-comment">//指令地址寄存器</span><br>    <span class="hljs-variable">.pc_clk</span>(clk),               <span class="hljs-comment">//PC寄存器的时钟信号，写入为同步（时钟下降沿有效），读取为异步</span><br>    <span class="hljs-variable">.pc_ena</span>(ena),               <span class="hljs-comment">//使能端信号，高电平有效</span><br>    <span class="hljs-variable">.rst_n</span>(rst_n),              <span class="hljs-comment">//复位信号，高电平有效</span><br>    <span class="hljs-variable">.pc_addr_in</span>(pc_addr_in),    <span class="hljs-comment">//本次输入PC寄存器的指令地址，也就是下一次要执行的指令</span><br>    <span class="hljs-variable">.pc_addr_out</span>(pc_addr_out)   <span class="hljs-comment">//本次从PC寄存器中传出的指令地址，也就是当前需要执行的指令</span><br>    );<br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h3 id="数据存储器DMEM"><a href="#数据存储器DMEM" class="headerlink" title="数据存储器DMEM"></a>数据存储器DMEM</h3><p>字长为32bit的数据存储器</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 1ns / 1ps</span><br><span class="hljs-comment">/* 数据存储器 */</span><br><span class="hljs-keyword">module</span> DMEM(<br>   <span class="hljs-keyword">input</span> D_clk,            <span class="hljs-comment">//时钟信号</span><br>   <span class="hljs-keyword">input</span> D_ena,            <span class="hljs-comment">//使能信号</span><br>   <span class="hljs-keyword">input</span> D_r,              <span class="hljs-comment">//读信号</span><br>   <span class="hljs-keyword">input</span> D_w,              <span class="hljs-comment">//写信号</span><br>   <span class="hljs-keyword">input</span> [<span class="hljs-number">10</span>:<span class="hljs-number">0</span>] D_addr,    <span class="hljs-comment">//地址</span><br>   <span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] D_data_in, <span class="hljs-comment">//数据输入</span><br>   <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] D_data_out<span class="hljs-comment">//数据输出</span><br>);<br><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] dmem [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>];<span class="hljs-comment">//DMEM</span><br><br><span class="hljs-keyword">assign</span> D_data_out = (D_ena &amp;&amp; D_r &amp;&amp; !D_w) ? dmem[D_addr] : <span class="hljs-number">32&#x27;bz</span>;<span class="hljs-comment">//使能信号、读信号有效，写信号无效时才有输出，否则均为高阻态</span><br><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">negedge</span> D_clk)<br>    <span class="hljs-keyword">if</span>(D_ena &amp;&amp; D_w &amp;&amp;!D_r)<br>        dmem[D_addr]&lt;=D_data_in;<br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure><h3 id="指令存储器IMEM"><a href="#指令存储器IMEM" class="headerlink" title="指令存储器IMEM"></a>指令存储器IMEM</h3><p>字长为32bit的指令存储器</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 1ns / 1ps</span><br><span class="hljs-keyword">module</span> IMEM(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">10</span>:<span class="hljs-number">0</span>] I_addr_in,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] I_instr_out<br>    ); <br><br>dist_mem_gen_0 imem(<br>    <span class="hljs-variable">.a</span>(I_addr_in),<br>    <span class="hljs-variable">.spo</span>(I_instr_out)<br>    );<br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure><h3 id="数据流sccomp-dataflow"><a href="#数据流sccomp-dataflow" class="headerlink" title="数据流sccomp_dataflow"></a>数据流sccomp_dataflow</h3><p>最顶层的文件，负责将指令存储器IMEM、数据存储器DMEM和CPU连接起来。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 1ns / 1ps</span><br><span class="hljs-keyword">module</span> sccomp_dataflow(<br>    <span class="hljs-keyword">input</span> clk_in,       <span class="hljs-comment">//时钟信号</span><br>    <span class="hljs-keyword">input</span> reset,        <span class="hljs-comment">//复位信号</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] inst, <span class="hljs-comment">//输出指令</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] pc    <span class="hljs-comment">//执行地址</span><br>    );<br><br><span class="hljs-comment">/* CPU管脚 */</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] pc_out;          <span class="hljs-comment">//输出指令地址，告诉IMEM要取哪条</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] dm_addr_temp;    <span class="hljs-comment">//DMEM临时地址，需要转化</span><br><br><br><span class="hljs-comment">/* IMEM管脚 */</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] im_addr_in;     <span class="hljs-comment">//11位指令码地址，从IMEM中读指令</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] im_instr_out;   <span class="hljs-comment">//32位指令码</span><br><br><span class="hljs-keyword">assign</span> im_addr_in = pc_out - <span class="hljs-number">32&#x27;h00400000</span>;<br><br><span class="hljs-comment">/* DMEM管脚 */</span><br><span class="hljs-keyword">wire</span> dm_ena;                <span class="hljs-comment">//是否需要启用DMEM</span><br><span class="hljs-keyword">wire</span> dm_r, dm_w;            <span class="hljs-comment">//读写指令</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] dm_addr;        <span class="hljs-comment">//需要用到的DMEM地址</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] dm_data_out;    <span class="hljs-comment">//DMEM读取时读取到的数据</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] dm_data_w;      <span class="hljs-comment">//要写入DMEM的内容 </span><br><br><span class="hljs-keyword">assign</span> dm_addr = (dm_addr_temp -  <span class="hljs-number">32&#x27;h10010000</span>)/<span class="hljs-number">4</span>;<br><br><span class="hljs-comment">/* 输出管脚 */</span><br><span class="hljs-keyword">assign</span> pc = pc_out;<br><span class="hljs-keyword">assign</span> inst = im_instr_out;<br><br><br><span class="hljs-comment">/* 指令存储器实例化 */</span><br>IMEM imem(<br>    <span class="hljs-variable">.I_addr_in</span>(im_addr_in[<span class="hljs-number">12</span>:<span class="hljs-number">2</span>]),  <span class="hljs-comment">//11位指令码地址，从IMEM中读指令</span><br>    <span class="hljs-variable">.I_instr_out</span>(im_instr_out)     <span class="hljs-comment">//32位指令码</span><br>    );<br><br><span class="hljs-comment">/* 数据存储器实例化 */</span><br>DMEM dmem(                      <span class="hljs-comment">//DMEM根据性能考量，设计成异步读取数据，同步写入数据的形式</span><br>    <span class="hljs-variable">.D_clk</span>(clk_in),            <span class="hljs-comment">//DMEM时钟信号，只在写数据时使用</span><br>    <span class="hljs-variable">.D_ena</span>(dm_ena),            <span class="hljs-comment">//使能信号端，高电平有效，有效时才能读取/写入数据</span><br>    <span class="hljs-variable">.D_r</span>(dm_r),                <span class="hljs-comment">//read读信号，读取时拉高</span><br>    <span class="hljs-variable">.D_w</span>(dm_w),                <span class="hljs-comment">//write写信号，写入时拉高</span><br>    <span class="hljs-variable">.D_addr</span>(dm_addr[<span class="hljs-number">10</span>:<span class="hljs-number">0</span>]),    <span class="hljs-comment">//11位地址，要读取/写入的地址</span><br>    <span class="hljs-variable">.D_data_in</span>(dm_data_w),     <span class="hljs-comment">//写入时要写入的数据</span><br>    <span class="hljs-variable">.D_data_out</span>(dm_data_out)   <span class="hljs-comment">//读取时读取到的数据</span><br>    );<br><br><span class="hljs-comment">/* CPU实例化 */</span><br>cpu sccpu(<br>    <span class="hljs-variable">.clk</span>(clk_in),               <span class="hljs-comment">//CPU执行时钟</span><br>    <span class="hljs-variable">.ena</span>(<span class="hljs-number">1&#x27;b1</span>),                 <span class="hljs-comment">//使能信号端</span><br>    <span class="hljs-variable">.rst_n</span>(reset),              <span class="hljs-comment">//复位信号</span><br>    <span class="hljs-variable">.instr_in</span>(im_instr_out),    <span class="hljs-comment">//当前要执行的指令</span><br>    <span class="hljs-variable">.dm_data</span>(dm_data_out),      <span class="hljs-comment">//读取到的DMEM的具体内容</span><br>    <span class="hljs-variable">.dm_ena</span>(dm_ena),            <span class="hljs-comment">//是否需要启用DMEM</span><br>    <span class="hljs-variable">.dm_w</span>(dm_w),                <span class="hljs-comment">//如果启用DMEM，是否为写入</span><br>    <span class="hljs-variable">.dm_r</span>(dm_r),                <span class="hljs-comment">//如果启用DMEM，是否为读取</span><br>    <span class="hljs-variable">.pc_out</span>(pc_out),            <span class="hljs-comment">//输出指令地址，告诉IMEM要取哪条</span><br>    <span class="hljs-variable">.dm_addr</span>(dm_addr_temp),     <span class="hljs-comment">//需要用到的DMEM地址</span><br>    <span class="hljs-variable">.dm_data_w</span>(dm_data_w)       <span class="hljs-comment">//要写入DMEM的内容 </span><br>    );<br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure><p>注意：指令存储器的实现用到了IP核。</p><h3 id="如何生成IP核："><a href="#如何生成IP核：" class="headerlink" title="如何生成IP核："></a>如何生成IP核：</h3><p><img src="/../img/CPU31-image-65.png" alt="alt text"><br>参数配置如下：<br><img src="/../img/CPU31-image-66.png" alt="alt text"><br><img src="/../img/CPU31-image-67.png" alt="alt text"><br><img src="/../img/CPU31-image-68.png" alt="alt text"><br>注：此处的Coefficients File使用的是coe文件，也就是存储CPU运行的程序的文件。</p><h3 id="如何获取-coe文件："><a href="#如何获取-coe文件：" class="headerlink" title="如何获取.coe文件："></a>如何获取.coe文件：</h3><p>在Mars中编写你想要测试的汇编代码，选择assemble指令进行编译<br><img src="/../img/CPU31-image-69.png" alt="alt text"><br>跳转到execude界面<br><img src="/../img/CPU31-image-70.png" alt="alt text"><br>之后将文件以16进制导出<br><img src="/../img/CPU31-image-71.png" alt="alt text"><br><img src="/../img/CPU31-image-72.png" alt="alt text"><br>将文件名后缀改为.coe,之后就能将该coe文件导入IP核了。<br><img src="/../img/CPU31-image-73.png" alt="alt text"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asm"># 示例：addi指令的测试代码<br>sll $0,$0,0<br>addi $0,$0,0xffffffff<br>addi $1,$0,0x0001<br>addi $2,$0,0xffff8000<br>addi $3,$0,0x7fff<br>addi $4,$1,0xffffffff<br>addi $5,$2,0xffffffff<br>addi $6,$3,0x0006<br></code></pre></td></tr></table></figure><p>至此，我们的CPU就能正常运行代码啦，不过需要运行的代码都需要通过以上这种形式转为coe文件导入IP核才能运行</p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPU</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
